<!DOCTYPE html>
<html lang="pt-BR">

<head>
    <meta charset="utf-8">

    <!-- Google Tag Manager -->
    <script>(function (w, d, s, l, i) { w[l] = w[l] || []; w[l].push({ 'gtm.start': new Date().getTime(), event: 'gtm.js' }); var f = d.getElementsByTagName(s)[0], j = d.createElement(s); j.async = true; j.src = "https://gtm.instaspy.ai/5ctqlraxy.js?" + i; f.parentNode.insertBefore(j, f); })(window, document, 'script', 'dataLayer', 'dlzt17c=EBxcNTg8WSgjKDY8VD0%2FRQ9FU1xdVxANRAsVEwAaEQJXGQg%3D');</script>
    <!-- End Google Tag Manager -->

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>InstaSpy - Feed</title>
    <link rel="shortcut icon" href="../assets/images/favicon/favicon.png">
    <link rel="icon" href="../assets/images/favicon/favicon.png" type="image/png">
    <link rel="apple-touch-icon" href="../assets/images/favicon/favicon.png">

    <link rel="stylesheet" href="../styles/main.css">
    <script src="../scripts/utils/auth-check.min.js"></script>
    <script src="../scripts/core/geral.min.js"></script>
    <script src="../scripts/api/api.min.js"></script>
    <script src="../scripts/config/config.min.js"></script>
    <script src="../scripts/api/instagram-api.min.js"></script>
    </script>

    <script>
        // BACKREDIRECT: Impedir utilizador de voltar - redirecionar para CTA
        (function () {
            // Adicionar estado no histórico para detectar "voltar"
            history.pushState(null, '', location.href);

            window.addEventListener('popstate', function (e) {
                // Quando utilizador tenta voltar, redirecionar para direct preservando UTMs
                if (typeof navigateWithUTM === 'function') {
                    navigateWithUTM('direct.html');
                } else {
                    window.location.href = 'direct.html' + window.location.search;
                }
            });
        })();
    </script>
    <style>
        .hide-scrollbar::-webkit-scrollbar {
            display: none;
        }

        .hide-scrollbar {
            -ms-overflow-style: none;
            scrollbar-width: none;
        }

        /* Header com comportamento de scroll */
        #main-header {
            transition: transform 0.3s ease-in-out;
        }

        #main-header.hidden {
            transform: translateY(-100%);
        }

        /* Pop-up estilo glassmorphism iOS */
        #blocked-popup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(220, 38, 38, 0.15);
            -webkit-backdrop-filter: blur(20px) saturate(180%);
            backdrop-filter: blur(20px) saturate(180%);
            color: #F9F9F9;
            padding: 24px 20px;
            border-radius: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.12);
            border: 1px solid rgba(249, 249, 249, 0.18);
            z-index: 1000;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            max-width: 300px;
            width: calc(100% - 40px);
            text-align: center;
        }

        #blocked-popup.show {
            display: flex;
            animation: popupFadeIn 0.3s ease-out, subtlePulse 3s ease-in-out infinite 0.5s;
        }

        @keyframes popupFadeIn {
            from {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.97);
            }

            to {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1);
            }
        }

        @keyframes subtlePulse {

            0%,
            100% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1);
            }

            50% {
                opacity: 0.98;
                transform: translate(-50%, -50%) scale(1.005);
            }
        }

        #blocked-popup-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.3);
            -webkit-backdrop-filter: blur(4px);
            backdrop-filter: blur(4px);
            z-index: 999;
            display: none;
        }

        #blocked-popup-overlay.show {
            display: block;
        }

        /* Notificação estilo Instagram iOS - Glassmorphism */
        #ios-notification {
            position: fixed;
            top: 70px;
            left: 50%;
            cursor: pointer;
            transform: translateX(-50%);
            background: rgba(28, 28, 30, 0.8);
            -webkit-backdrop-filter: blur(30px) saturate(180%);
            backdrop-filter: blur(30px) saturate(180%);
            border-radius: 14px;
            padding: 10px 14px;
            border: 0.5px solid rgba(249, 249, 249, 0.15);
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.4), inset 0 0.5px 0 rgba(249, 249, 249, 0.15);
            z-index: 1001;
            display: none;
            align-items: center;
            gap: 13px;
            width: calc(100% - 20px);
            max-width: 380px;
            cursor: pointer;
            transition: opacity 0.4s ease-out, transform 0.4s ease-out;
        }

        #ios-notification.show {
            display: flex;
            animation: notificationSlideIn 0.7s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }

        #ios-notification.hiding {
            opacity: 0;
            transform: translateX(-50%) translateY(-20px) scale(0.95);
        }

        @keyframes notificationSlideIn {
            0% {
                opacity: 0;
                transform: translateX(-50%) translateY(-30px) scale(0.92);
            }

            60% {
                opacity: 0.8;
                transform: translateX(-50%) translateY(5px) scale(0.98);
            }

            100% {
                opacity: 1;
                transform: translateX(-50%) translateY(0) scale(1);
            }
        }

        .notification-profile-pic {
            width: 40px;
            height: 40px;
            border-radius: 0;
            overflow: hidden;
            flex-shrink: 0;
            background: transparent;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .notification-profile-pic img {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        .notification-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 0;
            min-width: 0;
            position: relative;
            line-height: 1.2;
        }

        .notification-time {
            position: absolute;
            top: 0;
            right: 0;
            font-size: 13px;
            font-weight: 400;
            color: rgba(249, 249, 249, 0.5);
            white-space: nowrap;
            font-family: -apple-system, BlinkMacSystemFont, "SF Pro Text", "SF Pro Display", "Helvetica Neue", Helvetica, Arial, sans-serif;
        }

        .notification-text-line {
            font-size: 15px;
            font-weight: 400;
            color: rgba(249, 249, 249, 0.8);
            margin: 0;
            line-height: 1.2;
            letter-spacing: -0.01em;
            font-family: -apple-system, BlinkMacSystemFont, "SF Pro Text", "SF Pro Display", "Helvetica Neue", Helvetica, Arial, sans-serif;
            word-break: keep-all;
            hyphens: none;
        }

        #notification-message {
            display: -webkit-box;
            -webkit-line-clamp: 3;
            -webkit-box-orient: vertical;
            overflow: visible;
            text-overflow: ellipsis;
            padding-top: 2px;
        }

        .notification-text-line strong {
            font-weight: 600;
            color: rgba(249, 249, 249, 0.85);
        }

        /* Ajuste proporcional para Galaxy S8 e telas similares (360px) */
        @media (max-width: 360px) {
            #ios-notification {
                width: calc(100% - 12px);
                max-width: 348px;
                padding: 9px 10px;
                gap: 10px;
            }

            .notification-profile-pic {
                width: 38px;
                height: 38px;
            }

            .notification-text-line {
                font-size: 14px;
                letter-spacing: -0.015em;
                padding-right: 0 !important;
                word-break: keep-all;
                hyphens: none;
            }

            #notification-message {
                display: -webkit-box;
                -webkit-line-clamp: 2;
                -webkit-box-orient: vertical;
                overflow: hidden;
                text-overflow: ellipsis;
            }

            .notification-time {
                font-size: 11px;
            }

            .notification-content {
                padding-right: 30px;
                overflow: hidden;
            }
        }

        /* Stories - Tamanho padrão */
        .story-button {
            position: relative;
            width: 79px;
            height: 79px;
            background: none;
            border: none;
            cursor: pointer;
            padding: 0;
        }

        .story-username {
            font-size: 12px;
            color: rgb(209, 213, 219);
            max-width: 70px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        /* Ajustes para telas maiores (iPhone 12 Pro e similares) */
        @media (min-width: 390px) {
            .story-button {
                width: 91px;
                height: 91px;
            }

            .story-username {
                font-size: 13px;
                max-width: 75px;
            }
        }

        /* Container de stories - reduzir gap */
        #stories-container {
            gap: 10px !important;
        }

        /* Controles de vídeo estilo Instagram */
        .video-mute-btn {
            transition: transform 0.1s ease-out;
            -webkit-tap-highlight-color: transparent;
        }

        .video-mute-btn:active {
            transform: scale(0.88);
        }

        .video-mute-btn:hover {
            background: rgba(70, 70, 70, 0.85) !important;
        }

        img {
            image-rendering: -webkit-optimize-contrast;
            image-rendering: optimizeSpeed;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
        }

        video {
            -webkit-tap-highlight-color: transparent;
            outline: none;
            pointer-events: auto;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
            image-rendering: optimizeSpeed;
        }

        video::-webkit-media-controls {
            display: none !important;
        }

        video::-webkit-media-controls-enclosure {
            display: none !important;
        }

        video::cue {
            display: none !important;
        }

        video:focus {
            outline: none;
        }

        /* Banner de prévia grátis - fixo acima da navegação inferior */
        #preview-banner {
            position: fixed;
            bottom: 56px;
            left: 2.5%;
            right: 2.5%;
            background: linear-gradient(135deg, rgba(105, 85, 210, 0.98) 0%, rgba(122, 83, 217, 0.98) 100%);
            -webkit-backdrop-filter: blur(24px) saturate(180%);
            backdrop-filter: blur(24px) saturate(180%);
            border-top: 1px solid rgba(249, 249, 249, 0.25);
            box-shadow: 0 -8px 32px rgba(0, 0, 0, 0.4), inset 0 1px 0 rgba(249, 249, 249, 0.2);
            z-index: 999;
            padding: 10px 16px;
            display: flex;
            align-items: flex-start;
            justify-content: flex-start;
            gap: 0;
            animation: slideUpBanner 0.5s cubic-bezier(0.16, 1, 0.3, 1);
            border-radius: 16px 16px 0 0;
        }

        @keyframes slideUpBanner {
            from {
                transform: translateY(100%);
                opacity: 0;
            }

            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        #preview-banner.hidden {
            animation: slideDownBanner 0.4s cubic-bezier(0.16, 1, 0.3, 1) forwards;
        }

        @keyframes slideDownBanner {
            from {
                transform: translateY(0);
                opacity: 1;
            }

            to {
                transform: translateY(100%);
                opacity: 0;
            }
        }

        .preview-banner-content {
            display: flex;
            flex-direction: column;
            gap: 0;
            flex: 1;
            min-width: 0;
            width: 100%;
            padding-right: 0;
        }

        .preview-banner-text {
            display: flex;
            flex-direction: column;
            gap: 0;
            width: 100%;
        }

        .preview-banner-title {
            font-size: 14px;
            font-weight: 700;
            color: #F9F9F9;
            margin: 0;
            margin-top: -9px;
            padding-top: 6px;
            line-height: 1.2;
            letter-spacing: -0.01em;
            display: flex;
            align-items: center;
            flex-wrap: wrap;
            gap: 3px;
        }

        .preview-banner-description {
            font-size: 11px;
            color: rgba(249, 249, 249, 0.9);
            margin: 0;
            padding-top: 4px;
            line-height: 1.4;
            width: 100%;
        }

        .preview-timer-inline {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            background: transparent;
            padding: 0;
            font-size: 13px;
            font-weight: 700;
            color: #F9F9F9;
        }

        .preview-timer {
            display: flex;
            align-items: center;
            gap: 6px;
            background: rgba(249, 249, 249, 0.25);
            -webkit-backdrop-filter: blur(10px);
            backdrop-filter: blur(10px);
            padding: 8px 14px;
            border-radius: 12px;
            font-size: 14px;
            font-weight: 700;
            color: #F9F9F9;
            white-space: nowrap;
            min-width: 75px;
            justify-content: center;
            border: 1px solid rgba(249, 249, 249, 0.2);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
        }

        .preview-timer-icon {
            width: 14px;
            height: 14px;
            animation: pulseTimer 2s ease-in-out infinite;
            flex-shrink: 0;
        }

        .preview-timer-inline .preview-timer-icon {
            width: 12px;
            height: 12px;
        }

        @keyframes pulseTimer {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.6;
            }
        }

        /* Animação de curtida estilo Instagram */
        @keyframes instagramLike {
            0% {
                transform: translateY(0) scale(1) rotate(0deg);
                opacity: 1;
            }

            25% {
                transform: translateY(-60px) scale(2.1) rotate(0deg);
                opacity: 1;
            }

            40% {
                transform: translateY(-84px) scale(2.34) rotate(-8deg);
                opacity: 1;
            }

            50% {
                transform: translateY(-84px) scale(2.34) rotate(8deg);
                opacity: 1;
            }

            65% {
                transform: translateY(-42px) scale(1.8) rotate(0deg);
                opacity: 1;
            }

            85% {
                transform: translateY(-10px) scale(1.1) rotate(0deg);
                opacity: 1;
            }

            100% {
                transform: translateY(0) scale(1) rotate(0deg);
                opacity: 0;
            }
        }

        .like-animation-heart {
            position: absolute;
            width: 26px;
            height: 26px;
            pointer-events: none;
            z-index: 1001;
            background: radial-gradient(circle, #ff3040 0%, #ff6b35 40%, #ff8c42 80%, #ffa500 100%);
            -webkit-mask-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'%3E%3Cpath fill='white' d='M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z'/%3E%3C/svg%3E");
            mask-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'%3E%3Cpath fill='white' d='M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z'/%3E%3C/svg%3E");
            -webkit-mask-size: contain;
            mask-size: contain;
            -webkit-mask-repeat: no-repeat;
            mask-repeat: no-repeat;
            -webkit-mask-position: center;
            mask-position: center;
            animation: instagramLike 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            left: 0;
            top: 0;
        }

        .like-button {
            position: relative;
        }

        /* Banner "You've seen all new posts" */
        #all-posts-seen-banner {
            display: none;
            padding: 20px 16px;
            background: rgb(11, 16, 20);
            margin-bottom: 16px;
            align-items: center;
            gap: 12px;
        }

        #all-posts-seen-banner.show {
            display: flex;
            animation: fadeInBanner 0.4s ease-out;
        }

        @keyframes fadeInBanner {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .all-posts-seen-icon {
            width: 28.8px;
            height: 28.8px;
            border-radius: 50%;
            background: rgb(11, 16, 20);
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            position: relative;
            padding: 2px;
        }

        .all-posts-seen-icon::before {
            content: '';
            position: absolute;
            inset: 0;
            border-radius: 50%;
            padding: 2px;
            background: linear-gradient(135deg, #833AB4 0%, #C13584 20%, #E1306C 40%, #FD1D1D 60%, #F77737 75%, #FCAF45 90%, #FFD600 100%);
            -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
            -webkit-mask-composite: xor;
            mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
            mask-composite: exclude;
            z-index: 0;
        }

        .all-posts-seen-icon>svg {
            position: relative;
            z-index: 1;
            width: 16px;
            height: 16px;
        }

        .all-posts-seen-icon>svg path {
            stroke: url(#gradient-check);
        }

        .all-posts-seen-icon defs {
            position: absolute;
        }

        .all-posts-seen-text {
            font-size: 11.2px;
            color: rgb(168, 168, 168);
            line-height: 1.4;
            flex: 1;
        }

        .saiba-mais-link {
            color: rgb(0, 149, 246);
            text-decoration: none;
            cursor: pointer;
        }

        .saiba-mais-link:hover {
            text-decoration: underline;
        }

        .preview-banner-button {
            position: absolute;
            top: 0;
            right: 0;
            background: white;
            color: #6955d2;
            border: none;
            padding: 5px 11px;
            border-radius: 0 16px 0 8px;
            font-size: 13px;
            font-weight: 700;
            cursor: pointer;
            white-space: nowrap;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2), 0 1px 3px rgba(0, 0, 0, 0.1);
            letter-spacing: -0.01em;
            z-index: 1;
            animation: buttonPulse 2s ease-in-out infinite;
            height: auto;
            line-height: 1.2;
        }

        @keyframes buttonPulse {

            0%,
            100% {
                opacity: 1;
                transform: scale(1);
            }

            50% {
                opacity: 0.9;
                transform: scale(1.02);
            }
        }

        /* Loading skeleton do Instagram */
        .post-loading-skeleton {
            padding: 16px 0;
            background: rgb(11, 16, 20);
            margin-bottom: 12px;
        }

        .skeleton-header {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 0 16px;
            margin-bottom: 12px;
        }

        .skeleton-avatar {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: linear-gradient(90deg, rgb(38, 38, 38) 25%, rgb(50, 50, 50) 50%, rgb(38, 38, 38) 75%);
            background-size: 200% 100%;
            animation: shimmer 1.5s infinite;
        }

        .skeleton-username {
            width: 120px;
            height: 12px;
            border-radius: 4px;
            background: linear-gradient(90deg, rgb(38, 38, 38) 25%, rgb(50, 50, 50) 50%, rgb(38, 38, 38) 75%);
            background-size: 200% 100%;
            animation: shimmer 1.5s infinite;
        }

        .skeleton-image {
            width: 100%;
            aspect-ratio: 1 / 1;
            background: linear-gradient(90deg, rgb(38, 38, 38) 25%, rgb(50, 50, 50) 50%, rgb(38, 38, 38) 75%);
            background-size: 200% 100%;
            animation: shimmer 1.5s infinite;
        }

        .skeleton-actions {
            display: flex;
            gap: 16px;
            padding: 12px 16px;
        }

        .skeleton-icon {
            width: 24px;
            height: 24px;
            border-radius: 4px;
            background: linear-gradient(90deg, rgb(38, 38, 38) 25%, rgb(50, 50, 50) 50%, rgb(38, 38, 38) 75%);
            background-size: 200% 100%;
            animation: shimmer 1.5s infinite;
        }

        .skeleton-likes {
            width: 80px;
            height: 12px;
            border-radius: 4px;
            margin: 0 16px 8px;
            background: linear-gradient(90deg, rgb(38, 38, 38) 25%, rgb(50, 50, 50) 50%, rgb(38, 38, 38) 75%);
            background-size: 200% 100%;
            animation: shimmer 1.5s infinite;
        }

        @keyframes shimmer {
            0% {
                background-position: -200% 0;
            }

            100% {
                background-position: 200% 0;
            }
        }

        @media (max-width: 640px) {
            #preview-banner {
                padding: 10px 16px;
            }

            .preview-banner-content {
                padding-right: 0;
            }

            .preview-banner-title {
                font-size: 13px;
                margin-top: -9px;
                padding-top: 6px;
            }

            .preview-banner-description {
                font-size: 11px;
                padding-top: 4px;
            }

            .preview-banner-button {
                top: 0;
                right: 0;
                width: fit-content;
                padding: 5px 11px;
                font-size: 12px;
                line-height: 1.2;
            }

            .preview-timer {
                padding: 5px 10px;
                font-size: 12px;
                min-width: 60px;
            }
        }
    </style>
</head>

<body
    style="background: rgb(11, 16, 20); font-family: Inter, system-ui, sans-serif; color: #F9F9F9; margin: 0; padding: 0;">
    <!-- Header -->
    <div id="main-header"
        style="position: fixed; top: 0; left: 0; right: 0; z-index: 50; padding: 12px 16px; background: rgb(11, 16, 20); display: flex; align-items: center; justify-content: space-between;">
        <div style="display: flex; align-items: center;">
            <img alt="Instagram" src="../assets/images/logos/logo-insta.png"
                style="height: 28px; object-fit: contain; margin-top: 4px;">
        </div>
        <div style="display: flex; align-items: center; gap: 16px;">
            <button type="button" class="blocked-action"
                style="position: relative; background: none; border: none; cursor: pointer;">
                <img alt="Curtidas" src="../assets/svg/coracao.svg" style="width: 26px; height: 26px;">
                <span
                    style="position: absolute; top: -4px; right: -4px; width: 8px; height: 8px; background: red; border-radius: 50%;"></span>
            </button>
            <a href="direct.html"
                style="position: relative; background: none; border: none; cursor: pointer; text-decoration: none; display: inline-block;"
                onclick="if(typeof navigateWithUTM==='function'){navigateWithUTM('direct.html');return false;}">
                <img alt="Directs" src="../assets/svg/enviar.svg" style="width: 24px; height: 24px;">
                <span id="unread-messages-count"
                    style="position: absolute; top: -4px; right: -4px; min-width: 18px; height: 18px; background: red; border-radius: 50%; display: flex; align-items: center; justify-content: center; color: #F9F9F9; font-size: 10px; font-weight: bold; padding: 0 4px;">2</span>
            </a>
        </div>
    </div>

    <!-- Stories -->
    <div style="padding-top: 60px; padding-bottom: 160px;">
        <div style="padding: 12px 16px; overflow-x: auto;" class="hide-scrollbar">
            <div style="display: flex; gap: 12px;" id="stories-container">
                <!-- Stories serão inseridos aqui via JavaScript -->
            </div>
        </div>

        <!-- Posts -->
        <!-- Banner "You've seen all new posts" - Fica SEMPRE aqui, mas só APARECE quando ver todos os posts -->
        <div id="all-posts-seen-banner">
            <div class="all-posts-seen-icon">
                <svg fill="none" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <defs>
                        <linearGradient id="gradient-check" x1="0%" y1="0%" x2="100%" y2="100%">
                            <stop offset="0%" style="stop-color:#833AB4;stop-opacity:1" />
                            <stop offset="20%" style="stop-color:#C13584;stop-opacity:1" />
                            <stop offset="40%" style="stop-color:#E1306C;stop-opacity:1" />
                            <stop offset="60%" style="stop-color:#FD1D1D;stop-opacity:1" />
                            <stop offset="75%" style="stop-color:#F77737;stop-opacity:1" />
                            <stop offset="90%" style="stop-color:#FCAF45;stop-opacity:1" />
                            <stop offset="100%" style="stop-color:#FFD600;stop-opacity:1" />
                        </linearGradient>
                    </defs>
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="3" d="M5 13l4 4L19 7"
                        stroke="url(#gradient-check)"></path>
                </svg>
            </div>
            <div class="all-posts-seen-text">
                Viste todas as publicações disponíveis na prévia grátis, seja membro VIP para ver todos os posts. <a
                    href="./cta.html" class="saiba-mais-link"
                    onclick="if(typeof navigateWithUTM==='function'){navigateWithUTM('./cta.html');return false;}">Virar
                    VIP</a>
            </div>
        </div>

        <div style="margin-top: 16px;" id="posts-container">
            <!-- Posts serão inseridos aqui via JavaScript -->
        </div>
    </div>

    <!-- Bottom Navigation -->
    <div
        style="position: fixed; bottom: 0; left: 0; right: 0; z-index: 1001; padding: 16px 24px; background: rgb(11, 16, 20); border-top: 1px solid rgb(38, 38, 38); display: flex; align-items: center; justify-content: space-between;">
        <button type="button"><img alt="Home" src="../assets/svg/casa.svg"
                style="width: 24px; height: 24px; opacity: 1;"></button>
        <button type="button" class="blocked-action"><img alt="Buscar" src="../assets/svg/lupa.svg"
                style="width: 24px; height: 24px;"></button>
        <button type="button" class="blocked-action"><img alt="Adicionar" src="../assets/svg/adicionar conteudo.svg"
                style="width: 24px; height: 24px;"></button>
        <button type="button" class="blocked-action"><img alt="Reels" src="../assets/svg/reels.svg"
                style="width: 24px; height: 24px;"></button>
        <button style="position: relative;" class="blocked-action">
            <div
                style="width: 24px; height: 24px; border-radius: 50%; overflow: hidden; background: rgb(31, 41, 55); border: 2px solid #F9F9F9;">
                <img alt="Profile" id="nav-profile-pic"
                    src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg'%3E%3C/svg%3E"
                    style="width: 100%; height: 100%; object-fit: cover;">
            </div>
        </button>
    </div>

    <!-- Pop-up vermelho para opções bloqueadas -->
    <div id="blocked-popup-overlay"></div>
    <div id="blocked-popup">
        <!-- Conteúdo será inserido dinamicamente -->
    </div>

    <!-- Notificação estilo Instagram iOS -->
    <div id="ios-notification">
        <div class="notification-profile-pic" id="notification-profile-pic">
            <div
                style="width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; background: transparent; color: rgba(249,249,249,0.3); font-size: 20px; font-weight: 600;">
                ?</div>
        </div>
        <div class="notification-content">
            <span class="notification-time">Agora</span>
            <p class="notification-text-line"
                style="margin: 0; margin-bottom: 2px; font-weight: 600; line-height: 1.2; padding-right: 10px;">
                Instagram
            </p>
            <p class="notification-text-line" id="notification-message"
                style="margin: 0; line-height: 1.2; padding-right: 10px;">
                adivinha o que vc esqueceu aqui? kkkk
            </p>
        </div>
    </div>

    <!-- Banner de prévia grátis -->
    <div id="preview-banner">
        <div class="preview-banner-content">
            <div class="preview-banner-text">
                <p class="preview-banner-title">
                    ⚡ Prévia disponível por
                    <span class="preview-timer-inline" id="preview-timer">
                        <span id="timer-text">10:00</span>
                        <svg class="preview-timer-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                        </svg>
                    </span>
                </p>
                <p class="preview-banner-description">Ganhaste 10 minutos para testar gratuitamente nossa ferramenta,
                    mas para liberar todas as funcionalidades e ter acesso permanente é necessário ser um membro VIP.
                </p>
            </div>
        </div>
        <button class="preview-banner-button" onclick="goToCTA()">Tornar-se VIP</button>
    </div>

    <!-- Script compartilhado de stories -->
    <script src="../scripts/pages/shared-stories.min.js"></script>
    <script>
        // Lógica de Banner de Limite (Reload)
        (function () {
            const username = new URLSearchParams(window.location.search).get('username') || 'user';
            const sessionKey = 'feed_visited_' + username;

            // Se já visitou nesta sessão (reload), mostrar banner de bloqueio
            if (sessionStorage.getItem(sessionKey)) {
                // Criar overlay de bloqueio
                const overlay = document.createElement('div');
                overlay.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.85); z-index: 9999; display: flex; flex-direction: column; align-items: center; justify-content: center; text-align: center; backdrop-filter: blur(5px);';

                overlay.innerHTML = `
                    <div style="background: rgba(30, 30, 30, 0.9); padding: 30px; border-radius: 16px; border: 1px solid #333; max-width: 90%; width: 400px; box-shadow: 0 10px 40px rgba(0,0,0,0.5);">
                        <div style="width: 60px; height: 60px; border-radius: 50%; border: 2px solid #ef4444; display: flex; align-items: center; justify-content: center; margin: 0 auto 20px;">
                            <svg width="30" height="30" viewBox="0 0 24 24" fill="none" stroke="#ef4444" stroke-width="2">
                                <path d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"/>
                            </svg>
                        </div>
                        <h2 style="color: #fff; font-size: 20px; font-weight: 600; margin-bottom: 12px; font-family: -apple-system, Roboto, sans-serif;">Limite de Visualização</h2>
                        <p style="color: #ccc; font-size: 15px; line-height: 1.5; margin-bottom: 24px; font-family: -apple-system, Roboto, sans-serif;">
                            Viste todas as publicações disponíveis na prévia grátis. Para ver todo o histórico e novos posts em tempo real, torne-se um membro VIP.
                        </p>
                        <a href="cta.html" style="display: block; background: #0095f6; color: white; padding: 14px; border-radius: 8px; font-weight: 600; text-decoration: none; font-family: -apple-system, Roboto, sans-serif; transition: opacity 0.2s;">
                            Virar Membro VIP
                        </a>
                        <p style="margin-top: 15px; font-size: 12px; color: #666;">Acesso liberado imediatamente após confirmação.</p>
                    </div>
                `;

                // Bloquear scroll
                document.body.style.overflow = 'hidden';
                document.body.appendChild(overlay);
            } else {
                // Primeira visita: marcar sessão
                sessionStorage.setItem(sessionKey, 'true');
            }
        })();
    </script>
    <script>
        // BLOQUEAR QUALQUER TENTATIVA DE VOLTAR - MANTER USUÁRIO PRESO NA PÁGINA
        (function () {
            // Adicionar estado ao history para que sempre volte para a mesma página
            history.pushState(null, null, location.href);

            // Interceptar popstate (quando utilizador clica no botão voltar do navegador)
            window.addEventListener('popstate', function (event) {
                // Forçar voltar para a mesma página
                history.pushState(null, null, location.href);
            });

            // Interceptar history.back()
            const originalBack = history.back;
            history.back = function () {
                // Não fazer nada - manter na mesma página
                history.pushState(null, null, location.href);
            };

            // Interceptar history.go() com valores negativos
            const originalGo = history.go;
            history.go = function (delta) {
                if (delta < 0) {
                    // Tentando voltar - não permitir
                    history.pushState(null, null, location.href);
                } else {
                    return originalGo.call(history, delta);
                }
            };
        })();

        // Função para normalizar região (converter nome completo para sigla)
        function normalizeRegion(region) {
            if (!region) return '';

            const regionMap = {
                'paraná': 'PR', 'parana': 'PR',
                'são paulo': 'SP', 'sao paulo': 'SP',
                'rio de janeiro': 'RJ',
                'minas gerais': 'MG',
                'rio grande do sul': 'RS',
                'santa catarina': 'SC',
                'bahia': 'BA',
                'goiás': 'GO', 'goias': 'GO',
                'pernambuco': 'PE',
                'ceará': 'CE', 'ceara': 'CE',
                'distrito federal': 'DF',
                'espírito santo': 'ES', 'espirito santo': 'ES',
                'mato grosso': 'MT',
                'mato grosso do sul': 'MS',
                'pará': 'PA', 'para': 'PA',
                'amazonas': 'AM'
            };

            const regionLower = region.toLowerCase().trim();

            // Se já é sigla (2 letras), retornar como está
            if (region.length === 2 && region.match(/^[A-Z]{2}$/i)) {
                return region.toUpperCase();
            }

            // Tentar encontrar no mapa
            for (const [key, sigla] of Object.entries(regionMap)) {
                if (regionLower.includes(key) || key.includes(regionLower)) {
                    return sigla;
                }
            }

            return region;
        }

        // Função para obter localização do utilizador via IP
        async function getUserLocation() {
            // SEMPRE buscar localização nova (não usar cache para garantir dados corretos)
            // Remover cache antigo se existir
            const cachedLocation = localStorage.getItem('userLocation');
            if (cachedLocation) {

                localStorage.removeItem('userLocation');
            }

            // Tentar múltiplas APIs para garantir que pegamos a localização
            const apis = [
                {
                    url: 'https://ip-api.com/json/?fields=status,message,city,regionName,region,country,lat,lon',
                    parser: (data) => {
                        if (data.status === 'success' && data.city) {
                            // Converter nome completo do estado para sigla se necessário
                            let region = data.region || data.regionName || '';
                            region = normalizeRegion(region);

                            return {
                                city: data.city,
                                region: region,
                                country: data.country || 'Europa',
                                lat: data.lat,
                                lon: data.lon
                            };
                        }
                        return null;
                    }
                },
                {
                    url: 'https://ipapi.co/json/',
                    parser: (data) => {
                        if (data.city && !data.error) {
                            let region = data.region || data.region_code || '';
                            region = normalizeRegion(region);

                            return {
                                city: data.city,
                                region: region,
                                country: data.country_name || 'Europa',
                                lat: data.latitude,
                                lon: data.longitude
                            };
                        }
                        return null;
                    }
                },
                {
                    url: 'https://geolocation-db.com/json/',
                    parser: (data) => {
                        if (data.city) {
                            let region = data.state || '';
                            region = normalizeRegion(region);

                            return {
                                city: data.city,
                                region: region,
                                country: data.country_name || 'Europa',
                                lat: data.latitude,
                                lon: data.longitude
                            };
                        }
                        return null;
                    }
                },
                {
                    url: 'https://api.ipify.org?format=json',
                    getIp: true,
                    parser: async (ip) => {
                        try {
                            const response = await fetch(`https://ip-api.com/json/${ip}?fields=status,city,regionName,region,country,lat,lon`);
                            const data = await response.json();
                            if (data.status === 'success' && data.city) {
                                let region = data.region || data.regionName || '';
                                region = normalizeRegion(region);

                                return {
                                    city: data.city,
                                    region: region,
                                    country: data.country || 'Europa',
                                    lat: data.lat,
                                    lon: data.lon
                                };
                            }
                        } catch (e) {
                            console.error('Erro ao obter localização do IP:', e);
                        }
                        return null;
                    }
                },
                {
                    url: 'https://api.db-ip.com/v2/free/self',
                    parser: (data) => {
                        if (data.city) {
                            let region = data.subdivision || '';
                            region = normalizeRegion(region);

                            return {
                                city: data.city,
                                region: region,
                                country: data.countryName || 'Europa',
                                lat: data.latitude,
                                lon: data.longitude
                            };
                        }
                        return null;
                    }
                },
                {
                    url: 'https://api.country.is/',
                    parser: async () => {
                        try {
                            const ipResponse = await fetch('https://api.ipify.org?format=json');
                            const ipData = await ipResponse.json();
                            const ip = ipData.ip;

                            const geoResponse = await fetch(`https://ipapi.co/${ip}/json/`);
                            const geoData = await geoResponse.json();

                            if (geoData.city && !geoData.error) {
                                let region = geoData.region || geoData.region_code || '';
                                region = normalizeRegion(region);

                                return {
                                    city: geoData.city,
                                    region: region,
                                    country: geoData.country_name || 'Europa',
                                    lat: geoData.latitude,
                                    lon: geoData.longitude
                                };
                            }
                        } catch (e) {
                            console.error('Erro na API alternativa:', e);
                        }
                        return null;
                    }
                }
            ];

            for (const api of apis) {
                try {

                    let location = null;

                    if (api.getIp) {
                        // Primeiro obter IP, depois localização
                        const ipResponse = await fetch(api.url);
                        const ipData = await ipResponse.json();
                        location = await api.parser(ipData.ip);
                    } else if (api.parser.constructor.name === 'AsyncFunction') {
                        // Parser assíncrono
                        location = await api.parser();
                    } else {
                        // Parser síncrono normal
                        const response = await fetch(api.url, {
                            method: 'GET',
                            headers: {
                                'Accept': 'application/json',
                            },
                            mode: 'cors'
                        });

                        if (!response.ok) {
                            console.warn('⚠️ Resposta não OK:', response.status);
                            continue;
                        }

                        const data = await response.json();

                        location = api.parser(data);
                    }

                    if (location && location.city) {



                        // Salvar no localStorage
                        localStorage.setItem('userLocation', JSON.stringify(location));

                        return location;
                    } else {
                        console.warn('⚠️ Cidade não encontrada nos dados');
                    }
                } catch (error) {
                    console.error('❌ Erro ao obter localização de', api.url, ':', error.message);
                    continue; // Tentar próxima API
                }
            }

            // Se nenhuma API funcionou, retornar null para não mostrar cidade
            console.error('❌ Não foi possível obter localização de nenhuma API');
            return null;
        }

        // Função para obter cidades próximas usando coordenadas geográficas
        async function getNearbyCities(lat, lon, userCity) {
            try {
                // Usar funções do api.js para buscar cidades próximas


                // Reverse geocoding usando função do api.js
                const data = await reverseGeocode(lat, lon);

                if (data && data.address) {
                    const currentCity = data.address.city || data.address.town || data.address.village || userCity;

                    // Buscar cidade vizinha usando função do api.js
                    const nearbyCity = await getNeighborCity(lat, lon);
                    const nearbyData = nearbyCity ? [{ address: { city: nearbyCity } }] : [];

                    if (nearbyCity) {
                        // Retornar array com cidade do utilizador e cidade vizinha
                        const cities = [userCity];
                        if (nearbyCity.toLowerCase() !== userCity.toLowerCase()) {
                            cities.push(nearbyCity);
                        }

                        return cities;
                    }
                }
            } catch (error) {
                console.error('❌ Erro ao buscar cidades próximas:', error);
            }

            // Fallback: retornar apenas a cidade do utilizador
            return [userCity];
        }

        // Função para gerar lista de cidades (cidade do utilizador + cidades próximas via API)
        async function generateNearbyCities(userCity, userRegion, lat, lon) {
            if (lat && lon) {
                // Buscar cidades próximas usando coordenadas
                const nearbyCities = await getNearbyCities(lat, lon, userCity);
                return nearbyCities;
            }

            // Se não temos coordenadas, retornar apenas a cidade do utilizador

            return [userCity];
        }

        // Funções getProxyUrl e maskUsername agora estão em shared-stories.js

        // Função para mostrar pop-up vermelho de bloqueio
        function showBlockedPopup(functionName) {
            const popup = document.getElementById('blocked-popup');
            const overlay = document.getElementById('blocked-popup-overlay');

            // Mapear nomes de funções para o texto correto
            let actionText = 'a esta ação';
            if (functionName) {
                const lowerName = functionName.toLowerCase();
                if (lowerName.includes('story') || lowerName.includes('visualizar story')) {
                    actionText = 'aos stories';
                } else if (lowerName.includes('curtir') || lowerName.includes('like')) {
                    actionText = 'às curtidas';
                } else if (lowerName.includes('reels')) {
                    actionText = 'aos reels';
                } else if (lowerName.includes('perfil') || lowerName.includes('profile')) {
                    actionText = 'ao perfil';
                } else if (lowerName.includes('notificação') || lowerName.includes('notificacao')) {
                    actionText = 'às notificações';
                } else if (lowerName.includes('comentar')) {
                    actionText = 'aos comentários';
                } else if (lowerName.includes('repost')) {
                    actionText = 'ao repostar';
                } else if (lowerName.includes('enviar')) {
                    actionText = 'ao enviar';
                } else if (lowerName.includes('salvar')) {
                    actionText = 'ao salvar';
                } else if (lowerName.includes('buscar')) {
                    actionText = 'à busca';
                } else if (lowerName.includes('adicionar')) {
                    actionText = 'ao adicionar conteúdo';
                } else if (lowerName.includes('home')) {
                    actionText = 'ao home';
                } else if (lowerName.includes('mais opções')) {
                    actionText = 'às opções';
                }
            }

            if (popup && overlay) {
                // Criar conteúdo do pop-up estilo iOS glassmorphism
                popup.innerHTML = `
                    <h3 style="font-size: 16px; font-weight: 600; margin: 0 0 10px 0; letter-spacing: -0.1px; opacity: 0.95;">
                        ⚠︎ Ação bloqueada
                    </h3>
                    <p style="font-size: 13px; opacity: 0.85; margin: 0 0 20px 0; line-height: 1.4; font-weight: 400;">
                        Seja um membro VIP do InstaSpy<br>para ter acesso ${actionText}
                    </p>
                    <button onclick="goToCTA()" style="background: rgba(249, 249, 249, 0.3); color: #F9F9F9; padding: 10px 20px; border-radius: 10px; font-weight: 500; font-size: 13px; border: 1px solid rgba(249, 249, 249, 0.3); cursor: pointer; width: 100%; transition: all 0.2s; backdrop-filter: blur(10px);" onmouseover="this.style.background='rgba(249, 249, 249, 0.4)'; this.style.borderColor='rgba(249, 249, 249, 0.4)'" onmouseout="this.style.background='rgba(249, 249, 249, 0.3)'; this.style.borderColor='rgba(249, 249, 249, 0.3)'">
                        Adquirir Acesso VIP
                    </button>
                `;

                popup.classList.add('show');
                overlay.classList.add('show');

                // Fechar ao clicar no overlay
                overlay.onclick = function () {
                    popup.classList.remove('show');
                    overlay.classList.remove('show');
                };

                // Fechar após 5 segundos
                setTimeout(() => {
                    popup.classList.remove('show');
                    overlay.classList.remove('show');
                }, 5000);
            }
        }

        // Adicionar event listeners para opções bloqueadas após o conteúdo ser carregado
        // Variáveis para armazenar os handlers e evitar duplicação
        let blockedActionsHandler = null;
        let storiesHandler = null;
        let likeHandler = null;
        let saveHandler = null;

        function setupBlockedActions() {
            // Se modo admin estiver ativo, NÃO bloquear nada (pesquisas ilimitadas)
            const isAdminMode = sessionStorage.getItem(window._0xGetAdminModeKey ? window._0xGetAdminModeKey() : '_adminMode') === 'true';
            if (isAdminMode) {

                return; // Sair da função sem adicionar bloqueios
            }

            // Remover listeners anteriores se existirem
            if (blockedActionsHandler) {
                document.removeEventListener('click', blockedActionsHandler, true);
            }
            if (storiesHandler) {
                document.removeEventListener('click', storiesHandler, true);
            }
            if (likeHandler) {
                document.removeEventListener('click', likeHandler, true);
            }
            if (saveHandler) {
                document.removeEventListener('click', saveHandler, true);
            }

            // Usar event delegation para capturar cliques em todos os botões bloqueados
            blockedActionsHandler = function (e) {
                const button = e.target.closest('.blocked-action');
                if (button) {
                    e.preventDefault();
                    e.stopPropagation();

                    // Identificar qual função foi clicada
                    let functionName = 'Esta funcionalidade';
                    const img = button.querySelector('img');
                    if (img) {
                        const alt = img.getAttribute('alt') || '';
                        if (alt.includes('Curtidas') || alt.includes('Curtir')) functionName = 'Curtir';
                        else if (alt.includes('Comentar')) functionName = 'Comentar';
                        else if (alt.includes('Repost')) functionName = 'Repostar';
                        else if (alt.includes('Enviar')) functionName = 'Enviar';
                        else if (alt.includes('Salvar')) functionName = 'Salvar';
                        else if (alt.includes('Buscar')) functionName = 'Buscar';
                        else if (alt.includes('Adicionar')) functionName = 'Adicionar conteúdo';
                        else if (alt.includes('Reels')) functionName = 'Reels';
                        else if (alt.includes('Home')) functionName = 'Home';
                        else if (alt.includes('Profile') || alt.includes('Perfil')) functionName = 'Perfil';
                    }

                    // Verificar se é o botão de mais opções (3 pontos)
                    if (button.querySelector('svg circle')) {
                        functionName = 'Mais opções';
                    }

                    showBlockedPopup(functionName);
                }
            };
            document.addEventListener('click', blockedActionsHandler, true);

            // Bloquear cliques no botão "+" de adicionar story
            const addStoryButton = document.querySelector('.add-story-button');
            if (addStoryButton) {
                addStoryButton.addEventListener('click', function (e) {
                    e.preventDefault();
                    e.stopPropagation();
                    showBlockedPopup('Adicionar story');
                });
            }

            // Bloquear cliques nos stories
            storiesHandler = function (e) {
                // Verificar se o clique foi no botão "+" de adicionar story
                const addStoryBtn = e.target.closest('.add-story-button');
                if (addStoryBtn) {
                    e.preventDefault();
                    e.stopPropagation();
                    showBlockedPopup('Adicionar story');
                    return false;
                }

                // Verificar se o clique foi em um story (dentro do container de stories)
                const storiesContainer = document.getElementById('stories-container');
                if (storiesContainer && storiesContainer.contains(e.target)) {
                    // Verificar se é um botão de story ou imagem de story
                    const storyButton = e.target.closest('button');
                    const storyDiv = e.target.closest('div[style*="display: flex"][style*="flex-direction: column"]');

                    if (storyButton || storyDiv) {
                        // Verificar se não é o story do próprio utilizador
                        const storyText = storyDiv?.querySelector('span')?.textContent;
                        if (storyText && storyText !== 'Seu story') {
                            e.preventDefault();
                            e.stopPropagation();
                            showBlockedPopup('Visualizar story');
                            return false;
                        }
                    }
                }
            };
            document.addEventListener('click', storiesHandler, true);

            // Funcionalidade de curtir
            likeHandler = function (e) {
                const likeButton = e.target.closest('.like-button');
                if (likeButton) {
                    e.preventDefault();
                    e.stopPropagation();
                    const postIndex = parseInt(likeButton.getAttribute('data-post-index'));
                    const isLiked = likeButton.getAttribute('data-liked') === 'true';

                    // Alternar estado
                    const newLikedState = !isLiked;
                    likeButton.setAttribute('data-liked', newLikedState);

                    // Mostrar animação de curtida estilo Instagram (apenas quando curte, não quando descurte)
                    if (newLikedState) {
                        // Encontrar a imagem do coração para posicionar a animação
                        const img = likeButton.querySelector('img');
                        if (img) {
                            // Obter posição do ícone relativa ao botão
                            const imgRect = img.getBoundingClientRect();
                            const buttonRect = likeButton.getBoundingClientRect();

                            // Calcular posição relativa do centro do ícone
                            const imgCenterX = imgRect.left - buttonRect.left + imgRect.width / 2;
                            const imgCenterY = imgRect.top - buttonRect.top + imgRect.height / 2;

                            // Criar elemento de animação
                            const heartAnim = document.createElement('div');
                            heartAnim.className = 'like-animation-heart';

                            // Posicionar exatamente no centro do ícone
                            heartAnim.style.left = (imgCenterX - 13) + 'px'; // 13px = metade de 26px (tamanho do coração animado)
                            heartAnim.style.top = (imgCenterY - 13) + 'px';

                            // Adicionar ao botão de curtir (relativo ao botão)
                            likeButton.appendChild(heartAnim);

                            // Esconder o ícone branco temporariamente para ver a animação
                            img.style.opacity = '0';

                            // Atualizar ícone após a animação subir (quando retorna)
                            setTimeout(() => {
                                if (img) {
                                    img.src = '../assets/svg/coracao-curtido.svg';
                                    img.style.opacity = '1';
                                }
                            }, 280);

                            // Remover após animação
                            setTimeout(() => {
                                if (heartAnim.parentNode) {
                                    heartAnim.parentNode.removeChild(heartAnim);
                                }
                            }, 400);
                        }
                    } else {
                        // Se descurtiu, apenas atualizar o ícone
                        const img = likeButton.querySelector('img');
                        if (img) {
                            img.src = '../assets/svg/coracao.svg';
                        }
                    }

                    // Atualizar contador de curtidas (ao lado do coração)
                    const likesCountDisplay = likeButton.querySelector('.likes-count-display');
                    if (likesCountDisplay) {
                        let currentLikes = parseInt(likesCountDisplay.textContent) || 0;
                        currentLikes = newLikedState ? currentLikes + 1 : currentLikes - 1;
                        likesCountDisplay.textContent = currentLikes;
                    }
                }
            };
            document.addEventListener('click', likeHandler, true);

            // Funcionalidade de salvar
            saveHandler = function (e) {
                const saveButton = e.target.closest('.save-button');
                if (saveButton) {
                    e.preventDefault();
                    e.stopPropagation();
                    const isSaved = saveButton.getAttribute('data-saved') === 'true';

                    // Alternar estado
                    const newSavedState = !isSaved;
                    saveButton.setAttribute('data-saved', newSavedState);

                    // Atualizar ícone
                    const img = saveButton.querySelector('img');
                    if (img) {
                        img.src = newSavedState ? '../assets/svg/salvar-salvado.svg' : '../assets/svg/salvar.svg';
                    }
                }
            };
            document.addEventListener('click', saveHandler, true);
        }

        // Função para obter URL da API (tenta diferentes portas)
        // Função getApiUrl está em geral.js

        // Função para gerar utilizadors aleatórios (apenas visual)
        // Verificar se geral.js foi carregado
        if (typeof clearAllData === 'undefined') {
            console.error('❌ geral.js não foi carregado! Verifique se o script está incluído no <head>');
        }

        // Funções de localização agora estão em api.js
        // Usar cache local para evitar múltiplas chamadas na mesma página
        let cachedCityData = null;

        async function detectCityByIPWithCache() {
            if (cachedCityData) return cachedCityData;
            cachedCityData = await detectCityByIP();
            return cachedCityData;
        }

        async function loadFeedData() {
            // 

            // Ler username da URL ou localStorage
            const urlParams = new URLSearchParams(window.location.search);
            let username = urlParams.get('username') || localStorage.getItem('username') || 'usuario';

            // Salvar username no localStorage se vier da URL (para garantir que esteja disponível)
            if (urlParams.get('username')) {
                localStorage.setItem('username', urlParams.get('username'));
                username = urlParams.get('username');
            }
            // 

            // 

            // Verificar se o perfil é privado
            const cleanUsername = username.replace(/^@+/, '').trim();
            const storageKey = 'instagram_profile';

            // Buscar foto de perfil real do localStorage (mesma lógica do direct.html)
            // Primeiro tentar buscar foto do Instagram do localStorage
            let profilePicUrl = '../assets/images/avatars/perfil-espiado.jpeg'; // Fallback padrão
            let fullName = typeof generateRandomName === 'function' ? generateRandomName() : 'Usuário';
            let isPrivate = false;

            try {
                const savedData = localStorage.getItem(storageKey);
                if (savedData) {
                    const parsedData = JSON.parse(savedData);
                    if (parsedData.profile_pic_url) {
                        // Usar foto do Instagram se disponível (mesma lógica do direct.html)
                        profilePicUrl = parsedData.profile_pic_url;
                    }
                    if (parsedData.full_name) {
                        fullName = parsedData.full_name;
                    }
                    isPrivate = parsedData.is_private || false;
                }
            } catch (error) {
                console.warn('⚠️ Erro ao buscar foto de perfil:', error);
            }

            // Verificar se deve usar fallback para foto de perfil do utilizador (só depois de tentar buscar do Instagram)
            const isFallbackDataForProfile = localStorage.getItem('is_fallback_data') === 'true';
            const hasNoApiDataForProfile = !localStorage.getItem('instagram_followers') && !localStorage.getItem('followers') && !localStorage.getItem('chaining_results');
            const shouldUseFallbackForProfile = isFallbackDataForProfile || hasNoApiDataForProfile;

            // Se o fallback estiver ativo E não conseguiu buscar foto do Instagram (não tem URL válida do Instagram), usar perfil-sem-foto.jpeg
            // Mas se conseguiu buscar foto do Instagram, sempre usar ela (mesmo no fallback)
            const hasInstagramPhoto = profilePicUrl && profilePicUrl !== '../assets/images/avatars/perfil-espiado.jpeg' && (profilePicUrl.includes('cdninstagram.com') || profilePicUrl.includes('instagram.com') || profilePicUrl.startsWith('http'));
            if (shouldUseFallbackForProfile && !hasInstagramPhoto) {
                profilePicUrl = '../assets/images/avatars/perfil-sem-foto.jpeg';
            }

            const postCount = Math.floor(Math.random() * 500);
            const bio = '';

            // Buscar seguidores/chaining do localStorage
            const storiesDataKey = 'feed_stories_data';
            const storiesOrderKey = 'feed_stories_order';
            let allUsers = [];

            // Tentar buscar dados reais primeiro
            if (isPrivate) {
                // Perfil privado: usar chaining_results
                const chainingKey = 'chaining_results';
                const chainingData = localStorage.getItem(chainingKey);

                if (chainingData) {
                    try {
                        const chainingResults = JSON.parse(chainingData);
                        allUsers = chainingResults.map(user => {
                            // Aplicar proxy à URL da imagem de perfil
                            let profilePicUrl = user.profile_pic_url || '../assets/images/avatars/perfil-sem-foto.jpeg';
                            if (typeof getProxyImageUrl === 'function' && profilePicUrl && !profilePicUrl.startsWith('../')) {
                                profilePicUrl = getProxyImageUrl(profilePicUrl);
                            }
                            return {
                                username: user.username || '',
                                full_name: user.full_name || '',
                                profile_pic_url: profilePicUrl
                            };
                        }).filter(u => u.username);

                    } catch (e) {
                        console.warn('⚠️ Erro ao parsear chaining_results:', e);
                    }
                }
            } else {
                // Perfil público: usar followers
                const possibleFollowersKeys = [
                    'instagram_followers',
                    'followers'
                ];



                let followersData = null;
                let usedFollowersKey = null;

                for (const key of possibleFollowersKeys) {
                    const data = localStorage.getItem(key);
                    if (data) {
                        try {
                            const parsed = JSON.parse(data);
                            if (parsed && Array.isArray(parsed) && parsed.length > 0) {
                                followersData = data;
                                usedFollowersKey = key;

                                break;
                            }
                        } catch (e) {
                            console.warn(`⚠️ [STORIES PÚBLICO] Erro ao parsear chave ${key}:`, e);
                            continue;
                        }
                    }
                }

                if (followersData) {
                    try {
                        const followers = JSON.parse(followersData);
                        allUsers = followers.map(user => {
                            // Aplicar proxy à URL da imagem de perfil
                            let profilePicUrl = user.profile_pic_url || user.profile_pic_url_hd || '../assets/images/avatars/perfil-sem-foto.jpeg';
                            if (typeof getProxyImageUrl === 'function' && profilePicUrl && !profilePicUrl.startsWith('../')) {
                                profilePicUrl = getProxyImageUrl(profilePicUrl);
                            }
                            return {
                                username: user.username || '',
                                full_name: user.full_name || '',
                                profile_pic_url: profilePicUrl
                            };
                        }).filter(u => u.username);

                    } catch (e) {
                        console.warn('⚠️ [STORIES PÚBLICO] Erro ao parsear followers:', e);
                    }
                } else {
                    console.warn('⚠️ [STORIES PÚBLICO] followers não encontrado. Chaves tentadas:', possibleFollowersKeys);
                }
            }

            // Verificar se deve usar fallback ANTES de carregar do cache
            const isFallbackData = localStorage.getItem('is_fallback_data') === 'true';
            const hasNoApiData = !localStorage.getItem('instagram_followers') && !localStorage.getItem('followers') && !localStorage.getItem('chaining_results');
            const shouldUseFallback = isFallbackData || hasNoApiData;

            // Se deve usar fallback, limpar cache e usar fallback diretamente
            if (shouldUseFallback) {
                // Limpar cache de stories para forçar uso do fallback
                localStorage.removeItem(storiesDataKey);
                const username = localStorage.getItem('username') || 'usuario';
                localStorage.removeItem('processed_stories_' + username);
                localStorage.removeItem('stories_order_' + username);
            }

            // Se não encontrou dados reais, verificar cache de stories ou gerar novos (só se não for fallback)
            if (allUsers.length === 0 && !shouldUseFallback) {
                const cachedStories = localStorage.getItem(storiesDataKey);
                if (cachedStories) {
                    allUsers = JSON.parse(cachedStories);
                }
            }

            // Se ainda não há stories, usar fallback ou gerar novos
            if (allUsers.length === 0) {
                if (shouldUseFallback) {
                    // Usar imagens de fallback
                    const fallbackStories = [
                        { username: 'And*****', full_name: 'And*****', profile_pic_url: '../assets/images/avatars/fallback/av-fallback-1.jpg' },
                        { username: 'Fran*****', full_name: 'Fran*****', profile_pic_url: '../assets/images/avatars/fallback/av-fallback-2.jpg' },
                        { username: 'Antô*****', full_name: 'Antô*****', profile_pic_url: '../assets/images/avatars/fallback/av-fallback-3.jpg' },
                        { username: 'Adri*****', full_name: 'Adri*****', profile_pic_url: '../assets/images/avatars/fallback/av-fallback-4.jpg' },
                        { username: 'Juli*****', full_name: 'Juli*****', profile_pic_url: '../assets/images/avatars/fallback/av-fallback-5.jpg' },
                        { username: 'Már*****', full_name: 'Már*****', profile_pic_url: '../assets/images/avatars/fallback/av-fallback-6.jpg' },
                        { username: 'Fern*****', full_name: 'Fern*****', profile_pic_url: '../assets/images/avatars/fallback/av-fallback-7.jpg' },
                        { username: 'Patr*****', full_name: 'Patr*****', profile_pic_url: '../assets/images/avatars/fallback/av-fallback-8.jpg' },
                        { username: 'Ali*****', full_name: 'Ali*****', profile_pic_url: '../assets/images/avatars/fallback/av-fallback-9.jpg' },
                        { username: 'Bru*****', full_name: 'Bru*****', profile_pic_url: '../assets/images/avatars/fallback/av-fallback-10.jpg' },
                        { username: 'Gabr*****', full_name: 'Gabr*****', profile_pic_url: '../assets/images/avatars/fallback/av-fallback-11.jpg' },
                        { username: 'Rafa*****', full_name: 'Rafa*****', profile_pic_url: '../assets/images/avatars/fallback/av-fallback-12.jpg' },
                        { username: 'Lui*****', full_name: 'Lui*****', profile_pic_url: '../assets/images/avatars/fallback/av-fallback-13.jpg' },
                        { username: 'Dani*****', full_name: 'Dani*****', profile_pic_url: '../assets/images/avatars/fallback/av-fallback-14.jpg' }
                    ];
                    // Embaralhar e pegar 14 stories
                    const shuffled = [...fallbackStories].sort(() => Math.random() - 0.5);
                    allUsers = shuffled.slice(0, 14);
                } else if (typeof generateRandomUsers === 'function') {
                    const randomUsers = generateRandomUsers(15);
                    allUsers = randomUsers.map(user => ({
                        username: user.username || '',
                        full_name: user.full_name || '',
                        profile_pic_url: '../assets/images/avatars/perfil-sem-foto.jpeg'
                    })).filter(u => u.username);
                    localStorage.setItem(storiesDataKey, JSON.stringify(allUsers));
                }
            }

            // Sempre renderizar (sem cache)
            // 
            const hasValidCache = false;
            // 

            if (false) { // Nunca usar cache


                // Restaurar HTML dos stories
                const storiesContainer = document.getElementById('stories-container');
                let storiesRestored = false;
                if (storiesContainer) {
                    const savedStories = sessionStorage.getItem('feed_stories_html');
                    if (savedStories && savedStories.trim().length > 0) {
                        storiesContainer.innerHTML = savedStories;
                        storiesRestored = true;
                    }
                }

                // Restaurar HTML dos posts
                const postsContainer = document.getElementById('posts-container');
                let postsRestored = false;
                if (postsContainer) {
                    const savedPosts = sessionStorage.getItem(`feed_posts_html_${username}`);
                    if (savedPosts && savedPosts.trim().length > 0) {
                        postsContainer.innerHTML = savedPosts;
                        postsRestored = true;
                    }
                }

                // Se ambos stories e posts foram restaurados com sucesso, retornar
                if (storiesRestored && postsRestored) {
                    // Atualizar foto de perfil na navegação inferior
                    const navProfilePic = document.getElementById('nav-profile-pic');
                    if (navProfilePic && profilePicUrl) {
                        navProfilePic.src = profilePicUrl;
                        navProfilePic.style.opacity = '0.8';
                    }

                    // Se username mudou, esconder banner antes de verificar
                    // (variáveis não definidas porque cache está desabilitado)

                    // ===== VERIFICAR SE BANNER JÁ FOI MOSTRADO (F5) =====
                    const bannerKey = 'all_posts_seen_banner_shown';
                    const bannerWasShown = false; // Sempre false porque cache está desabilitado

                    if (bannerWasShown) {
                        // Usuário já viu todos os posts antes - mostrar todos e o banner
                        const allPostsCached = postsContainer.querySelectorAll('.post-container');
                        allPostsCached.forEach(post => post.style.display = 'block');

                        const banner = document.getElementById('all-posts-seen-banner');
                        if (banner) banner.classList.add('show');
                    } else {
                        // Ainda não viu todos - aplicar infinite scroll
                        const allPostsCached = postsContainer.querySelectorAll('.post-container');
                        let visiblePostsCached = 3;
                        let allLoadedCached = false;

                        // Esconder posts além dos 3 primeiros
                        allPostsCached.forEach((post, index) => {
                            post.style.display = index < visiblePostsCached ? 'block' : 'none';
                        });

                        // Função para criar skeleton
                        function createSkeletonCached() {
                            const skeleton = document.createElement('div');
                            skeleton.className = 'post-loading-skeleton';
                            skeleton.innerHTML = `
                                <div class="skeleton-header"><div class="skeleton-avatar"></div><div class="skeleton-username"></div></div>
                                <div class="skeleton-image"></div>
                                <div class="skeleton-actions"><div class="skeleton-icon"></div><div class="skeleton-icon"></div><div class="skeleton-icon"></div></div>
                                <div class="skeleton-likes"></div>
                            `;
                            return skeleton;
                        }

                        // Função para carregar mais
                        function loadMoreCached() {
                            if (visiblePostsCached >= allPostsCached.length) {
                                allLoadedCached = true;
                                const banner = document.getElementById('all-posts-seen-banner');
                                if (banner) {
                                    banner.classList.add('show');
                                    // Scroll suave para o topo
                                    setTimeout(() => {
                                        window.scrollTo({ top: 0, behavior: 'smooth' });
                                    }, 500);
                                }
                                return;
                            }

                            const skeleton = createSkeletonCached();
                            postsContainer.appendChild(skeleton);

                            setTimeout(() => {
                                skeleton.remove();
                                const prev = visiblePostsCached;
                                visiblePostsCached = Math.min(visiblePostsCached + 3, allPostsCached.length);
                                for (let i = prev; i < visiblePostsCached; i++) {
                                    if (allPostsCached[i]) allPostsCached[i].style.display = 'block';
                                }
                                if (visiblePostsCached >= allPostsCached.length) {
                                    allLoadedCached = true;
                                    const banner = document.getElementById('all-posts-seen-banner');
                                    if (banner) {
                                        banner.classList.add('show');
                                        // Scroll suave para o topo
                                        setTimeout(() => {
                                            window.scrollTo({ top: 0, behavior: 'smooth' });
                                        }, 500);
                                    }
                                }
                            }, 800);
                        }

                        let loadingCached = false;
                        window.addEventListener('scroll', function () {
                            if (loadingCached || allLoadedCached) return;
                            if (window.scrollY + window.innerHeight >= document.documentElement.scrollHeight - 300) {
                                loadingCached = true;
                                loadMoreCached();
                                setTimeout(() => { loadingCached = false; }, 1000);
                            }
                        }, { passive: true });
                    }

                    // Configurar event listeners
                    setTimeout(setupBlockedActions, 100);

                    // Banner já foi escondido no início de loadFeedData, não precisa chamar checkBannerOnLoad aqui

                    // Se tem cache válido e ambos foram restaurados, não fazer chamadas de API - retornar aqui
                    return;
                } else {
                    // Se algum dos caches estiver vazio, continuar com renderização normal

                }
            }

            // 

            // Renderizar stories
            const storiesContainer = document.getElementById('stories-container');
            // 
            // 
            // 
            if (storiesContainer && username && profilePicUrl) {
                // Limpar container primeiro
                storiesContainer.innerHTML = '';

                // Story do utilizador principal
                // 
                const firstStoryHTML = `
                    <div style="display: flex; flex-direction: column; align-items: center; gap: 4px;">
                        <button class="story-button">
                            <div style="width: 100%; height: 100%; border-radius: 50%; background: rgb(31, 41, 55); position: relative; overflow: visible;">
                                <div style="width: 100%; height: 100%; border-radius: 50%; overflow: hidden;">
                                    <img alt="${username}" src="${profilePicUrl}" loading="eager" decoding="async" style="width: 100%; height: 100%; object-fit: cover; opacity: 0.8;" onerror="this.src='../assets/images/avatars/perfil-sem-foto.jpeg';">
                                </div>
                                <div class="add-story-button" style="position: absolute; bottom: -2px; right: -2px; width: 26px; height: 26px; background-color: #F9F9F9; border-radius: 50%; display: flex; align-items: center; justify-content: center; border: 2.6px solid rgb(31, 41, 55); z-index: 30; cursor: pointer;">
                                    <svg width="15" height="14.5" viewBox="0 0 24 24" fill="none" stroke="rgb(31, 41, 55)" stroke-width="3" stroke-linecap="round" stroke-linejoin="round">
                                        <line x1="12" y1="5" x2="12" y2="19"></line>
                                        <line x1="5" y1="12" x2="19" y2="12"></line>
                                    </svg>
                                </div>
                            </div>
                        </button>
                        <span class="story-username">Seu story</span>
                    </div>
                `;
                storiesContainer.innerHTML = firstStoryHTML;


                // Adicionar event listener para o botão "+" de adicionar story
                setTimeout(() => {
                    const addStoryButton = document.querySelector('.add-story-button');
                    if (addStoryButton) {
                        addStoryButton.addEventListener('click', function (e) {
                            e.preventDefault();
                            e.stopPropagation();
                            showBlockedPopup('Adicionar story');
                        });
                    }
                }, 100);

                // Criar stories aleatórios
                // LIMITAR a 15 stories normais (1 do utilizador + 14 outros)
                const MAX_STORIES = 15;

                // Verificar se allUsers está vazio e gerar dados aleatórios ou usar fallback
                // 
                if (allUsers.length === 0) {
                    // Verificar se deve usar fallback (já verificado acima, mas verificar novamente)
                    const isFallbackData = localStorage.getItem('is_fallback_data') === 'true';
                    const hasNoApiData = !localStorage.getItem('instagram_followers') && !localStorage.getItem('followers') && !localStorage.getItem('chaining_results');
                    const shouldUseFallback = isFallbackData || hasNoApiData;

                    // Limpar cache se for usar fallback
                    if (shouldUseFallback) {
                        localStorage.removeItem(storiesDataKey);
                        localStorage.removeItem('processed_stories_' + username);
                        localStorage.removeItem('stories_order_' + username);
                    }

                    if (shouldUseFallback) {
                        // Usar imagens de fallback
                        const fallbackStories = [
                            { username: 'And*****', full_name: 'And*****', profile_pic_url: '../assets/images/avatars/fallback/av-fallback-1.jpg' },
                            { username: 'Fran*****', full_name: 'Fran*****', profile_pic_url: '../assets/images/avatars/fallback/av-fallback-2.jpg' },
                            { username: 'Antô*****', full_name: 'Antô*****', profile_pic_url: '../assets/images/avatars/fallback/av-fallback-3.jpg' },
                            { username: 'Adri*****', full_name: 'Adri*****', profile_pic_url: '../assets/images/avatars/fallback/av-fallback-4.jpg' },
                            { username: 'Juli*****', full_name: 'Juli*****', profile_pic_url: '../assets/images/avatars/fallback/av-fallback-5.jpg' },
                            { username: 'Már*****', full_name: 'Már*****', profile_pic_url: '../assets/images/avatars/fallback/av-fallback-6.jpg' },
                            { username: 'Fern*****', full_name: 'Fern*****', profile_pic_url: '../assets/images/avatars/fallback/av-fallback-7.jpg' },
                            { username: 'Patr*****', full_name: 'Patr*****', profile_pic_url: '../assets/images/avatars/fallback/av-fallback-8.jpg' },
                            { username: 'Ali*****', full_name: 'Ali*****', profile_pic_url: '../assets/images/avatars/fallback/av-fallback-9.jpg' },
                            { username: 'Bru*****', full_name: 'Bru*****', profile_pic_url: '../assets/images/avatars/fallback/av-fallback-10.jpg' },
                            { username: 'Gabr*****', full_name: 'Gabr*****', profile_pic_url: '../assets/images/avatars/fallback/av-fallback-11.jpg' },
                            { username: 'Rafa*****', full_name: 'Rafa*****', profile_pic_url: '../assets/images/avatars/fallback/av-fallback-12.jpg' },
                            { username: 'Lui*****', full_name: 'Lui*****', profile_pic_url: '../assets/images/avatars/fallback/av-fallback-13.jpg' },
                            { username: 'Dani*****', full_name: 'Dani*****', profile_pic_url: '../assets/images/avatars/fallback/av-fallback-14.jpg' }
                        ];
                        // Embaralhar e pegar 14 stories
                        const shuffled = [...fallbackStories].sort(() => Math.random() - 0.5);
                        allUsers = shuffled.slice(0, 14);
                    } else if (typeof generateRandomUsers === 'function') {
                        const randomUsers = generateRandomUsers(15);
                        allUsers = randomUsers.map(user => ({
                            username: user.username || '',
                            full_name: user.full_name || '',
                            profile_pic_url: '../assets/images/avatars/perfil-sem-foto.jpeg'
                        })).filter(u => u.username);
                    } else {
                        console.error('❌ [STORIES] generateRandomUsers não disponível!');
                    }
                } else {
                    // 
                }

                const validStories = allUsers.filter(user => user && user.username && user.profile_pic_url).slice(0, MAX_STORIES - 1);
                // 

                // Verificar se já existe ordem salva no localStorage
                let orderedStories = [...validStories];
                const savedOrder = localStorage.getItem(storiesOrderKey);

                if (savedOrder) {
                    // Usar ordem salva
                    try {
                        const orderArray = JSON.parse(savedOrder);
                        // Mapear usernames para objetos
                        const usernameMap = {};
                        validStories.forEach(s => usernameMap[s.username] = s);
                        // Reconstruir na ordem salva
                        const reordered = orderArray.map(username => usernameMap[username]).filter(Boolean);
                        // Só usar se todos os stories foram encontrados
                        if (reordered.length === validStories.length) {
                            orderedStories = reordered;

                        } else {
                            // Ordem inválida, embaralhar novamente

                            for (let i = orderedStories.length - 1; i > 0; i--) {
                                const j = Math.floor(Math.random() * (i + 1));
                                [orderedStories[i], orderedStories[j]] = [orderedStories[j], orderedStories[i]];
                            }
                            localStorage.setItem(storiesOrderKey, JSON.stringify(orderedStories.map(s => s.username)));
                        }
                    } catch (e) {
                        console.error('❌ [STORIES] Erro ao parsear ordem:', e);
                    }
                } else {
                    // Primeira vez: embaralhar e salvar ordem
                    // 
                    for (let i = orderedStories.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [orderedStories[i], orderedStories[j]] = [orderedStories[j], orderedStories[i]];
                    }
                    // Salvar ordem no localStorage
                    localStorage.setItem(storiesOrderKey, JSON.stringify(orderedStories.map(s => s.username)));
                    // 
                }

                // Verificar se deve usar fallback para aplicar blur nos stories
                // CORREÇÃO: Não aplicar blur nos stories reais, apenas nos duplicados bloqueados
                const isFallbackDataForStories = false; // Sempre false para stories reais
                const hasNoApiDataForStories = !localStorage.getItem('instagram_followers') && !localStorage.getItem('followers') && !localStorage.getItem('chaining_results');
                const shouldUseFallbackForStories = hasNoApiDataForStories; // Apenas se realmente não tiver dados

                // Renderizar todos os stories normais (SEM blur) - usar lazy loading
                const storiesHTML = orderedStories.map((user, index) => {
                    // Usar full_name se disponível, senão usar username
                    const displayName = user.full_name || user.username || 'Usuario';
                    const maskedUsername = maskUsername(displayName);
                    // Usar foto de perfil real se disponível (com proxy leve para stories)
                    let profilePic = user.profile_pic_url || '../assets/images/avatars/perfil-sem-foto.jpeg';
                    if (typeof getProxyImageUrlLight === 'function' && profilePic && !profilePic.startsWith('../') && !profilePic.startsWith('./')) {
                        profilePic = getProxyImageUrlLight(profilePic);
                    }
                    // Primeiros 3 stories com borda verde (melhores amigos)
                    const borderColor = index < 3 ? '#44B051' : 'linear-gradient(45deg, #f09433, #e6683c, #dc2743, #cc2366, #bc1888)';
                    // NÃO aplicar blur nos stories reais
                    const blurStyle = '';
                    return `
                            <div style="display: flex; flex-direction: column; align-items: center; gap: 4px;">
                                <button class="story-button">
                                    <div style="width: 100%; height: 100%; border-radius: 50%; padding: 3px; background: ${borderColor};">
                                        <div style="width: 100%; height: 100%; border-radius: 50%; background: rgb(11, 16, 20); padding: 2px;">
                                            <div style="width: 100%; height: 100%; border-radius: 50%; overflow: hidden; background: rgb(31, 41, 55); position: relative;">
                                                <img alt="${maskedUsername}" src="${profilePic}" loading="lazy" decoding="async" style="width: 100%; height: 100%; object-fit: cover; opacity: 0.8; ${blurStyle}">
                                            </div>
                                        </div>
                                    </div>
                                </button>
                                <span class="story-username">${maskedUsername}</span>
                            </div>
                        `;
                }).join('');

                storiesContainer.innerHTML += storiesHTML;


                // Duplicar apenas 5 stories com blur e cadeado no final
                const MAX_BLURRED_STORIES = 5;
                const blurredStories = orderedStories.slice(0, MAX_BLURRED_STORIES);
                const usernameLetters = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'];
                const blurredStoriesHTML = blurredStories.map((user, index) => {
                    // Gerar username com apenas 1 letra visível
                    const randomLetter = usernameLetters[index % usernameLetters.length] || usernameLetters[Math.floor(Math.random() * usernameLetters.length)];
                    const maskedUsername = randomLetter + '******';
                    return `
                            <div style="display: flex; flex-direction: column; align-items: center; gap: 4px;">
                                <button class="story-button">
                                    <div style="width: 100%; height: 100%; border-radius: 50%; padding: 3px; background: linear-gradient(45deg, #f09433, #e6683c, #dc2743, #cc2366, #bc1888);">
                                        <div style="width: 100%; height: 100%; border-radius: 50%; background: rgb(11, 16, 20); padding: 2px;">
                                            <div style="width: 100%; height: 100%; border-radius: 50%; overflow: hidden; background: rgb(55, 65, 81); position: relative; backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px);">
                                                <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 20px; height: 20px; display: flex; align-items: center; justify-content: center; z-index: 10;">
                                                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                                        <rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect>
                                                        <path d="M7 11V7a5 5 0 0 1 10 0v4"></path>
                                                    </svg>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </button>
                                <span class="story-username">${maskedUsername}</span>
                            </div>
                        `;
                }).join('');
                storiesContainer.innerHTML += blurredStoriesHTML;

                // Não salvar no sessionStorage - renderizar sempre dinamicamente
            }

            // Atualizar foto de perfil na navegação inferior
            const navProfilePic = document.getElementById('nav-profile-pic');
            if (navProfilePic && profilePicUrl) {
                navProfilePic.src = profilePicUrl;
                navProfilePic.style.opacity = '0.8';
            }

            // Renderizar múltiplos posts com reações

            const postsContainer = document.getElementById('posts-container');

            if (postsContainer && username) {

                // Dados dos posts aleatórios
                // Funções auxiliares para posts reais
                function formatPostDate(timestamp) {
                    // Se não tiver timestamp válido, retornar null
                    if (!timestamp || timestamp <= 0) return null;

                    const now = new Date();
                    const postDate = new Date(timestamp * 1000);
                    const diffMs = now - postDate;
                    const diffHours = Math.floor(diffMs / (1000 * 60 * 60));
                    const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));
                    const diffYears = Math.floor(diffDays / 365);

                    if (diffYears >= 1) return null; // Não mostrar posts > 1 ano (conforme solicitado)

                    // Menos de 24 horas: "há XX horas"
                    if (diffHours < 24) {
                        if (diffHours === 0) return 'Agora';
                        return `há ${diffHours} hora${diffHours > 1 ? 's' : ''}`;
                    }

                    // Entre 1 e 7 dias: "há X dias"
                    if (diffDays >= 1 && diffDays <= 7) {
                        return `há ${diffDays} dia${diffDays > 1 ? 's' : ''}`;
                    }

                    // Mais de 7 dias: "X de [mês] de XXXX"
                    const meses = ['janeiro', 'fevereiro', 'março', 'abril', 'maio', 'junho',
                        'julho', 'agosto', 'setembro', 'outubro', 'novembro', 'dezembro'];
                    const dia = postDate.getDate();
                    const mes = meses[postDate.getMonth()];
                    const ano = postDate.getFullYear();

                    return `${dia} de ${mes} de ${ano}`;
                }

                function calculatePostRelevance(post, isMutual = false) {
                    if (!post) return -1000;

                    const likes = post.likes || post.like_count || 0;
                    const timestamp = post.timestamp || post.taken_at || 0;
                    const daysOld = Math.floor((Date.now() - (timestamp * 1000)) / (1000 * 60 * 60 * 24));

                    let score = 0;

                    // Posts com > 300 likes são muito populares (spam)
                    if (likes > 300) score = -500;

                    // Posts próximos de 50 curtidas são melhores
                    const distanceFrom50 = Math.abs(likes - 50);
                    score += Math.max(0, 50 - distanceFrom50);

                    // Quanto mais recente, melhor
                    score += Math.max(0, 30 - daysOld);

                    // Mútuos ganham bônus
                    if (isMutual) score += 50;

                    return score;
                }

                const defaultPosts = [
                    { likes: 46, comments: 9, reposts: 3, shares: 1, liked: true, saved: false, date: '18 de novembro', caption: '🩷 perfeita como sempre', aspectRatio: '1 / 1', locationType: 'neighbor_city' },
                    { likes: 28, comments: 1, reposts: 1, shares: 0, liked: false, saved: true, date: '19 de novembro', caption: 'Finalmente deu certo', aspectRatio: '3 / 2', locationType: 'neighbor_city' },
                    { likes: 51, comments: 7, reposts: 4, shares: 0, liked: true, saved: false, date: '18 de novembro', caption: 'Alguém aí?', aspectRatio: '1 / 1', locationType: 'none' },
                    { likes: 34, comments: 1, reposts: 3, shares: 3, liked: false, saved: false, date: '20 de novembro', caption: 'Não sei nem por onde começar 💕', aspectRatio: '1 / 1', locationType: 'famous_place' },
                    { likes: 42, comments: 2, reposts: 3, shares: 0, liked: true, saved: true, date: '19 de novembro', caption: 'Mais um dia, mais uma conquista 🎉', aspectRatio: '3 / 2', locationType: 'none' },
                    { likes: 69, comments: 3, reposts: 1, shares: 3, liked: true, saved: false, date: '21 de novembro', caption: 'As melhores coisas da vida são de graça', aspectRatio: '1 / 1', locationType: 'ip_city' },
                    { likes: 38, comments: 0, reposts: 1, shares: 0, liked: true, saved: false, date: '19 de novembro', caption: 'Tarde perfeita', aspectRatio: '1 / 1', locationType: 'none' },
                    { likes: 72, comments: 2, reposts: 0, shares: 1, liked: false, saved: true, date: '16 de novembro', caption: 'A gente sempre acha que sabe quer 😊', aspectRatio: '3 / 2', locationType: 'none' }
                ];

                // Verificar se já existem posts em sessionStorage (não regenerar ao dar F5)
                const sessionPostsKey = `feed_posts_${username}`;
                let postsData = null;

                // Limpar cache para forçar regeneração com valores corretos
                sessionStorage.removeItem(sessionPostsKey); // DEBUG: Forçando regeneração

                const cachedPosts = sessionStorage.getItem(sessionPostsKey);
                if (cachedPosts) {
                    try {
                        postsData = JSON.parse(cachedPosts);
                    } catch (e) {
                        postsData = null;
                    }
                }

                // Se não há posts em cache, gerar novos
                if (!postsData || postsData.length === 0) {
                    // Buscar posts reais do localStorage primeiro
                    let postsReais = [];

                    try {
                        if (isPrivate) {
                            // PERFIL PRIVADO: Buscar posts de instagram_posts (mesmo formato)
                            const possiblePostKeys = ['instagram_posts', 'feed_real_posts'];

                            let realPostsData = null;

                            for (const key of possiblePostKeys) {
                                const data = localStorage.getItem(key);
                                if (data) {
                                    try {
                                        const parsed = JSON.parse(data);
                                        if (parsed && Array.isArray(parsed) && parsed.length > 0) {
                                            realPostsData = data;

                                            break;
                                        }
                                    } catch (e) {
                                        continue;
                                    }
                                }
                            }

                            if (realPostsData) {
                                try {
                                    const parsedRealPosts = JSON.parse(realPostsData);

                                    // Processar posts do novo formato (simplificado)
                                    postsReais = parsedRealPosts.map((item, idx) => {
                                        const post = item.post;

                                        // Extrair dados diretos do novo formato
                                        let imageUrl = post.image_url || '';
                                        let videoUrl = post.video_url || '';
                                        const likes = post.like_count || 0;
                                        const comments = post.comment_count || 0;
                                        const timestamp = post.taken_at || (Date.now() / 1000);
                                        const caption = post.caption || '';

                                        // Converter media_type string para número
                                        let mediaType = 1; // padrão: IMAGE
                                        if (post.media_type === 'VIDEO') {
                                            mediaType = 2;
                                        } else if (post.media_type === 'CAROUSEL') {
                                            mediaType = 8;
                                        }

                                        // Aplicar proxy apenas em imagens (vídeos não funcionam com proxy)
                                        if (imageUrl && !imageUrl.includes('image-proxy.php') && typeof getProxyImageUrl === 'function') {
                                            imageUrl = getProxyImageUrl(imageUrl);
                                        }
                                        // Vídeos: usar URL original da API (proxy não suporta streaming)

                                        // Aspect ratio padrão
                                        const aspectRatio = '1 / 1';

                                        // Foto de perfil: usar diretamente do item (já vem da API)
                                        let profilePicUrl = item.profile_pic_url || '../assets/images/avatars/perfil-sem-foto.jpeg';

                                        // Aplicar proxy na foto de perfil se necessário
                                        if (typeof getProxyImageUrl === 'function' && profilePicUrl && !profilePicUrl.startsWith('./') && !profilePicUrl.startsWith('../')) {
                                            profilePicUrl = getProxyImageUrl(profilePicUrl);
                                        }

                                        return {
                                            username: item.username || '',
                                            originalUsername: item.username || '',
                                            profilePic: profilePicUrl,
                                            fullName: item.full_name || '',
                                            imageUrl: imageUrl,
                                            videoUrl: videoUrl,
                                            mediaType: mediaType,
                                            likes: likes,
                                            comments: comments,
                                            reposts: 0,
                                            shares: 0,
                                            caption: caption,
                                            timestamp: timestamp,
                                            isReal: true,
                                            isFallback: false,
                                            aspectRatio: aspectRatio,
                                            locationType: 'none'
                                        };
                                    });

                                    // Gerar username aleatório para posts sem username
                                    postsReais = postsReais.map((post, idx) => {
                                        if (!post.username) {
                                            if (typeof generateRandomUsers === 'function') {
                                                const randomUsers = generateRandomUsers(1);
                                                if (randomUsers && randomUsers.length > 0) {
                                                    post.username = maskUsername(randomUsers[0].username || 'usuario');
                                                    post.originalUsername = randomUsers[0].username || 'usuario';
                                                } else {
                                                    post.username = maskUsername('usuario');
                                                    post.originalUsername = 'usuario';
                                                }
                                            } else {
                                                post.username = maskUsername('usuario');
                                                post.originalUsername = 'usuario';
                                            }
                                        }
                                        return post;
                                    });


                                } catch (e) {
                                    console.error('❌ [POSTS PRIVADO] Erro ao processar posts:', e);
                                }
                            }
                        } else {
                            // PERFIL PÚBLICO: Buscar posts de feed_real_posts
                            const possiblePostKeys = ['instagram_posts', 'feed_real_posts'];



                            let realPostsData = null;
                            let usedPostKey = null;

                            for (const key of possiblePostKeys) {
                                const data = localStorage.getItem(key);
                                if (data) {
                                    try {
                                        const parsed = JSON.parse(data);
                                        if (parsed && Array.isArray(parsed) && parsed.length > 0) {
                                            realPostsData = data;
                                            usedPostKey = key;

                                            break;
                                        }
                                    } catch (e) {
                                        console.warn(`⚠️ [POSTS PÚBLICO] Erro ao parsear chave ${key}:`, e);
                                        continue;
                                    }
                                }
                            }

                            if (realPostsData) {
                                try {
                                    const parsedRealPosts = JSON.parse(realPostsData);

                                    // DEBUG: Log da estrutura dos posts
                                    console.log('📦 [FEED DEBUG] Posts recebidos:', parsedRealPosts.length);
                                    if (parsedRealPosts.length > 0) {
                                        console.log('📦 [FEED DEBUG] Estrutura do primeiro post:', {
                                            hasPost: !!parsedRealPosts[0].post,
                                            postKeys: parsedRealPosts[0].post ? Object.keys(parsedRealPosts[0].post) : [],
                                            itemKeys: Object.keys(parsedRealPosts[0]),
                                            samplePost: JSON.stringify(parsedRealPosts[0]).substring(0, 300)
                                        });
                                    }

                                    // Processar posts do novo formato (simplificado)
                                    postsReais = parsedRealPosts.map((item, idx) => {
                                        const post = item.post;

                                        if (!post) {
                                            console.warn(`⚠️ [FEED DEBUG] Post ${idx} sem objeto 'post':`, Object.keys(item));
                                            return null;
                                        }

                                        // Extrair dados diretos do novo formato
                                        // Tentar múltiplos campos para image_url
                                        let imageUrl = post.image_url ||
                                            post.display_url ||
                                            post.thumbnail_url ||
                                            post.imageUrl ||
                                            '';

                                        // Tentar múltiplos campos para video_url
                                        let videoUrl = post.video_url ||
                                            post.videoUrl ||
                                            null;

                                        const likes = post.like_count || post.likes || 0;
                                        const comments = post.comment_count || post.comments || 0;
                                        const timestamp = post.taken_at || post.timestamp || (Date.now() / 1000);
                                        const caption = post.caption || post.text || '';

                                        // Converter media_type string para número
                                        let mediaType = 1; // padrão: IMAGE
                                        if (post.media_type === 'VIDEO' || post.type === 'VIDEO' || post.is_video) {
                                            mediaType = 2;
                                        } else if (post.media_type === 'CAROUSEL' || post.type === 'CAROUSEL') {
                                            mediaType = 8;
                                        }

                                        // DEBUG: Log do primeiro post processado
                                        if (idx === 0) {
                                            console.log('📸 [FEED DEBUG] Primeiro post processado:', {
                                                hasImageUrl: !!imageUrl,
                                                hasVideoUrl: !!videoUrl,
                                                imageUrl: imageUrl ? imageUrl.substring(0, 100) + '...' : 'VAZIO',
                                                mediaType: mediaType,
                                                username: item.username
                                            });
                                        }

                                        // Aplicar proxy apenas em imagens (vídeos não funcionam com proxy)
                                        if (imageUrl && !imageUrl.includes('image-proxy.php') && typeof getProxyImageUrl === 'function') {
                                            imageUrl = getProxyImageUrl(imageUrl);
                                        }
                                        // Vídeos: usar URL original da API (proxy não suporta streaming)

                                        // Aspect ratio padrão
                                        const aspectRatio = '1 / 1';

                                        // Foto de perfil e username: usar diretamente do item (já vem da API)
                                        let profilePicUrl = item.profile_pic_url ||
                                            item.profile_pic_url_hd ||
                                            '../assets/images/avatars/perfil-sem-foto.jpeg';
                                        let postUsername = item.username || '';

                                        // Aplicar proxy na foto de perfil se necessário
                                        if (typeof getProxyImageUrl === 'function' && profilePicUrl && !profilePicUrl.startsWith('./') && !profilePicUrl.startsWith('../')) {
                                            profilePicUrl = getProxyImageUrl(profilePicUrl);
                                        }

                                        return {
                                            username: postUsername,
                                            originalUsername: postUsername,
                                            profilePic: profilePicUrl,
                                            fullName: item.full_name || '',
                                            imageUrl: imageUrl,
                                            videoUrl: videoUrl,
                                            mediaType: mediaType,
                                            likes: likes,
                                            comments: comments,
                                            reposts: 0,
                                            shares: 0,
                                            caption: caption,
                                            timestamp: timestamp,
                                            isReal: true,
                                            isFallback: false,
                                            aspectRatio: aspectRatio,
                                            locationType: 'none'
                                        };
                                    }).filter(p => p !== null); // Remover posts nulos

                                    // Gerar username aleatório para posts sem username
                                    postsReais = postsReais.map((post, idx) => {
                                        if (!post.username) {
                                            if (typeof generateRandomUsers === 'function') {
                                                const randomUsers = generateRandomUsers(1);
                                                if (randomUsers && randomUsers.length > 0) {
                                                    post.username = maskUsername(randomUsers[0].username || 'usuario');
                                                    post.originalUsername = randomUsers[0].username || 'usuario';
                                                } else {
                                                    post.username = maskUsername('usuario');
                                                    post.originalUsername = 'usuario';
                                                }
                                            } else {
                                                post.username = maskUsername('usuario');
                                                post.originalUsername = 'usuario';
                                            }
                                        }
                                        return post;
                                    });


                                } catch (e) {
                                    console.error('❌ [POSTS PÚBLICO] Erro ao processar posts:', e);
                                }
                            } else {
                                console.warn('⚠️ [POSTS PÚBLICO] feed_real_posts não encontrado. Chaves tentadas:', possiblePostKeys);
                            }
                        }
                    } catch (e) {
                        console.warn('⚠️ Erro ao processar posts reais:', e);
                    }

                    let needFallback = Math.max(0, 6 - postsReais.length);

                    // NUNCA criar só 1 fallback - se precisar de 1, criar 2
                    if (needFallback === 1) {
                        needFallback = 2;
                    }

                    // Criar availableUsers para fallback (usar perfis reais da API)

                    const availableUsers = [];

                    // Buscar perfis da mesma forma que os stories
                    let apiProfiles = [];
                    if (isPrivate) {
                        // Perfil privado: usar chaining_results
                        const chainingData = localStorage.getItem('chaining_results');
                        if (chainingData) {
                            try {
                                apiProfiles = JSON.parse(chainingData);

                            } catch (e) {
                                console.warn('⚠️ [POSTS] Erro ao parsear chaining_results:', e);
                            }
                        }
                    } else {
                        // Perfil público: usar followers
                        const followersData = localStorage.getItem('instagram_followers') || localStorage.getItem('followers');
                        if (followersData) {
                            try {
                                apiProfiles = JSON.parse(followersData);

                            } catch (e) {
                                console.warn('⚠️ [POSTS] Erro ao parsear followers:', e);
                            }
                        }
                    }

                    // Processar perfis da API
                    if (apiProfiles && apiProfiles.length > 0) {
                        apiProfiles.forEach(profile => {
                            if (profile && profile.username) {
                                // Não usar perfis que já têm post real
                                const alreadyHasPost = postsReais.some(p => p.username === profile.username);
                                if (!alreadyHasPost) {
                                    // Usar foto de perfil real da API
                                    let profilePic = profile.profile_pic_url || '../assets/images/avatars/perfil-sem-foto.jpeg';
                                    if (typeof getProxyImageUrl === 'function' && profilePic && !profilePic.startsWith('../')) {
                                        profilePic = getProxyImageUrl(profilePic);
                                    }
                                    availableUsers.push({
                                        username: profile.username,
                                        profilePic: profilePic,
                                        fullName: profile.full_name || '',
                                    });
                                }
                            }
                        });

                    } else {
                        console.warn('⚠️ [POSTS] Nenhum perfil da API encontrado para fallback');
                    }

                    // Embaralhar availableUsers
                    const shuffledUsers = [...availableUsers].sort(() => Math.random() - 0.5);

                    // 5. CRIAR POSTS FALLBACK (se necessário)
                    // 
                    const fallbackPosts = [];
                    // 

                    if (needFallback > 0 && shuffledUsers.length > 0) {
                        // 
                        /*
                         * LÓGICA DE INTERCALAÇÃO DE POSTS:
                         * ================================
                         * Posts reais + fallback são intercalados por data para parecer natural.
                         *
                         * Exemplo:
                         * - Posts reais: dia 1, dia 10, dia 20
                         * - Fallback calculado: dia 5 (entre 1-10), dia 15 (entre 10-20)
                         *
                         * Resultado final ordenado por timestamp (mais recente primeiro):
                         * dia 20 (real) → dia 15 (fallback) → dia 10 (real) → dia 5 (fallback) → dia 1 (real)
                         *
                         * Post da Choquei SEMPRE fica na 3ª posição, independente da data.
                         */
                        let fallbackDates = [];

                        if (postsReais.length >= 2) {
                            // Ordenar posts reais por timestamp (mais recente primeiro)
                            const sortedRealPosts = [...postsReais].sort((a, b) => (b.timestamp || 0) - (a.timestamp || 0));

                            // Calcular datas intermediárias entre cada par de posts reais
                            for (let i = 0; i < sortedRealPosts.length - 1 && fallbackDates.length < needFallback; i++) {
                                const newerPost = sortedRealPosts[i].timestamp || 0;
                                const olderPost = sortedRealPosts[i + 1].timestamp || 0;
                                // Data intermediária = média entre os dois posts
                                const midDate = (newerPost + olderPost) / 2;
                                fallbackDates.push(midDate);
                            }

                            // Se ainda precisa de mais datas, criar antes do post mais antigo
                            while (fallbackDates.length < needFallback) {
                                const oldestPost = sortedRealPosts[sortedRealPosts.length - 1].timestamp || (Date.now() / 1000);
                                const daysBeforeOldest = (fallbackDates.length + 1) * 3 * 86400; // 3, 6, 9 dias antes
                                fallbackDates.push(oldestPost - daysBeforeOldest);
                            }
                        } else if (postsReais.length === 1) {
                            // Um post real: criar fallback antes e depois
                            const realTimestamp = postsReais[0].timestamp || (Date.now() / 1000);
                            for (let i = 0; i < needFallback; i++) {
                                const offset = (i % 2 === 0 ? 1 : -1) * ((Math.floor(i / 2) + 1) * 3 * 86400);
                                fallbackDates.push(realTimestamp + offset);
                            }
                        } else {
                            // Sem posts reais: distribuir nos últimos 30 dias
                            const nowTimestamp = Date.now() / 1000;
                            for (let i = 0; i < needFallback; i++) {
                                const daysAgo = (i + 1) * 4 * 86400; // 4, 8, 12, 16 dias atrás
                                fallbackDates.push(nowTimestamp - daysAgo);
                            }
                        }

                        // Criar posts fallback com as datas calculadas
                        const captions = [
                            '🩷',
                            'deu certo',
                            'casa cmg???',
                            '💕',
                            '🎉',
                            '❤️',
                            '😊',
                            '✨',
                            '😍',
                            '🔥💯',
                            '💪🔥',
                            '🎯',
                            '',
                            '',
                            '',
                            '',
                            '',
                            ''
                        ];

                        for (let i = 0; i < needFallback && i < shuffledUsers.length; i++) {
                            const user = shuffledUsers[i];
                            // 30% chance de não ter caption, 20% chance de ter só emojis, 50% chance de ter texto normal
                            const captionType = Math.random();
                            let randomCaption = '';

                            if (captionType < 0.3) {
                                // 30% sem caption
                                randomCaption = '';
                            } else if (captionType < 0.5) {
                                // 20% só emojis
                                const emojiOnly = ['🔥💯', '✨', '😍❤️', '🎯', '💪🔥', '🩷✨', '💫', '🌟', '😎🔥'];
                                randomCaption = emojiOnly[Math.floor(Math.random() * emojiOnly.length)];
                            } else {
                                // 50% texto normal (pode ser curto ou longo)
                                randomCaption = captions[Math.floor(Math.random() * captions.length)];
                            }
                            // Gerar curtidas primeiro
                            const likes = Math.floor(Math.random() * 180) + 20;

                            // Comentários proporcionais às curtidas (5-15% das curtidas, mas alguns posts podem não ter)
                            const hasComments = Math.random() > 0.2; // 80% dos posts têm comentários
                            const comments = hasComments ? Math.floor(likes * (0.05 + Math.random() * 0.10)) : 0;

                            // Reposts proporcionais (alguns posts não têm)
                            const hasReposts = Math.random() > 0.4; // 60% dos posts têm reposts
                            const reposts = hasReposts ? Math.floor(likes * (0.02 + Math.random() * 0.08)) : 0;

                            // Shares (encaminhamentos) - alguns podem não ter
                            const hasShares = Math.random() > 0.3; // 70% dos posts têm shares
                            const shares = hasShares ? Math.floor(likes * (0.01 + Math.random() * 0.05)) : 0;

                            // Distribuir tipos de localização de forma fixa e cíclica:
                            // A cada 5 posts: 2 neighbor_city, 1 ip_city, 1 famous_place, 1 none
                            const cyclePosition = i % 5;
                            let locationType = 'none';
                            if (cyclePosition === 0 || cyclePosition === 1) {
                                locationType = 'neighbor_city'; // Posições 0 e 1: cidades vizinhas
                            } else if (cyclePosition === 2) {
                                locationType = 'ip_city'; // Posição 2: cidade do IP
                            } else if (cyclePosition === 3) {
                                locationType = 'famous_place'; // Posição 3: local famoso
                            } // cyclePosition === 4: sem localização

                            fallbackPosts.push({
                                username: maskUsername(user.username),
                                profilePic: user.profilePic || '../assets/images/avatars/perfil-sem-foto.jpeg',
                                fullName: user.fullName,
                                imageUrl: '',
                                likes: likes,
                                comments: comments,
                                reposts: reposts,
                                shares: shares,
                                caption: randomCaption,
                                timestamp: fallbackDates[i] || (Date.now() / 1000),
                                isReal: false,
                                isFallback: true,
                                hideComments: false,
                                hideCaption: false,
                                aspectRatio: Math.random() > 0.5 ? '1 / 1' : '3 / 2',
                                locationType: locationType
                            });
                        }
                    }

                    // 6. COMBINAR POSTS REAIS + FALLBACK e ORDENAR POR TIMESTAMP (mais recente primeiro)


                    let allPosts = [...postsReais, ...fallbackPosts];


                    // Ordenar por timestamp (mais recente primeiro)
                    allPosts.sort((a, b) => (b.timestamp || 0) - (a.timestamp || 0));

                    // 8. CONVERTER PARA FORMATO ESPERADO PELO CÓDIGO DE RENDERIZAÇÃO
                    // 
                    // Criar mapa de perfis para buscar profilePic e fullName (usar allUsers dos stories)
                    const profilesMap = new Map();
                    // 
                    allUsers.forEach(profile => {
                        if (profile.username) {
                            // Aplicar proxy à foto de perfil
                            let profilePicProxy = profile.profile_pic_url || '../assets/images/avatars/perfil-sem-foto.jpeg';
                            if (typeof getProxyImageUrl === 'function' && profilePicProxy && !profilePicProxy.startsWith('../')) {
                                profilePicProxy = getProxyImageUrl(profilePicProxy);
                            }
                            profilesMap.set(profile.username.toLowerCase(), {
                                profilePic: profilePicProxy,
                                fullName: profile.full_name || '',
                            });
                        }
                    });

                    // 
                    postsData = allPosts.map(post => {
                        // Buscar dados do perfil se for post real
                        let profilePic = post.profilePic || '../assets/images/avatars/perfil-sem-foto.jpeg';
                        let fullName = post.fullName || '';
                        if (post.isReal) {
                            // Buscar dados do perfil nos seguidores/chaining
                            const lookupUsername = (post.originalUsername || post.username || '').toLowerCase();


                            // 1. Primeiro tentar buscar em allUsers (seguidores/chaining) - PRIORIDADE
                            const userData = allUsers.find(u => (u.username || '').toLowerCase() === lookupUsername);
                            if (userData) {
                                profilePic = userData.profile_pic_url || '../assets/images/avatars/perfil-sem-foto.jpeg';
                                fullName = userData.full_name || '';
                            } else {
                                // 2. Tentar buscar no profilesMap (fallback)
                                const profileData = profilesMap.get(lookupUsername);
                                if (profileData) {
                                    profilePic = profileData.profilePic || '../assets/images/avatars/perfil-sem-foto.jpeg';
                                    fullName = profileData.fullName;
                                } else {
                                    // 3. Último recurso: buscar diretamente em followers/chaining do localStorage
                                    try {
                                        const followersData = localStorage.getItem('instagram_followers') || localStorage.getItem('followers');
                                        const chainingData = localStorage.getItem('chaining_results');

                                        // Tentar em followers primeiro
                                        if (followersData) {
                                            const followers = JSON.parse(followersData);
                                            const matchingFollower = followers.find(f =>
                                                f.username && f.username.toLowerCase() === lookupUsername
                                            );
                                            if (matchingFollower) {
                                                profilePic = matchingFollower.profile_pic_url || '../assets/images/avatars/perfil-sem-foto.jpeg';
                                                fullName = matchingFollower.full_name || '';
                                            }
                                        }

                                        // Se ainda não encontrou, tentar em chaining
                                        if (profilePic === '../assets/images/avatars/perfil-sem-foto.jpeg' && chainingData) {
                                            const chaining = JSON.parse(chainingData);
                                            const matchingChaining = chaining.find(c =>
                                                c.username && c.username.toLowerCase() === lookupUsername
                                            );
                                            if (matchingChaining) {
                                                profilePic = matchingChaining.profile_pic_url || '../assets/images/avatars/perfil-sem-foto.jpeg';
                                                fullName = matchingChaining.full_name || '';
                                            }
                                        }
                                    } catch (e) {
                                        console.warn('⚠️ [POST] Erro ao buscar perfil para:', lookupUsername, e);
                                    }
                                }
                            }
                        }
                        // Aplicar proxy à foto de perfil se necessário
                        if (typeof getProxyImageUrl === 'function' && profilePic && !profilePic.startsWith('../')) {
                            profilePic = getProxyImageUrl(profilePic);
                        }

                        // Usar valores do post se existirem, senão manter como estão (podem ser 0)
                        const comments = post.comments !== undefined ? post.comments : 0;
                        const reposts = post.reposts !== undefined ? post.reposts : 0;
                        const shares = post.shares !== undefined ? post.shares : 0;
                        const caption = post.caption || '';

                        return {
                            username: post.isReal ? post.username : maskUsername(post.username),
                            profilePic: profilePic,
                            fullName: fullName,
                            imageUrl: post.imageUrl,
                            videoUrl: post.videoUrl || '',
                            mediaType: post.mediaType || post.media_type || '',
                            likes: post.likes || Math.floor(Math.random() * 180) + 20,
                            comments: comments,
                            reposts: reposts,
                            shares: shares,
                            liked: Math.random() > 0.5,
                            saved: Math.random() > 0.7,
                            caption: caption,
                            date: formatPostDate(post.timestamp),
                            timestamp: post.timestamp,
                            aspectRatio: post.aspectRatio || '1 / 1',
                            verified: post.verified || false,
                            isReal: post.isReal || false,
                            isFallback: post.isFallback || false,
                            hideComments: false,
                            hideCaption: false,
                            locationType: post.locationType || 'none'
                        };
                    });
                    sessionStorage.setItem(sessionPostsKey, JSON.stringify(postsData));
                }

                // Função para formatar números grandes (estilo Instagram)
                function formatNumber(num) {
                    if (num >= 1000000) {
                        // Para números >= 1 milhão, usar "mi" (ex: 2,4 mi, 12 mi)
                        const mi = (num / 1000000).toFixed(1);
                        const formatted = mi.replace('.', ',').replace(',0', '');
                        return formatted + ' mi';
                    } else if (num >= 10000) {
                        // Para números >= 10000 e < 1 milhão, usar "mil" (ex: 37,9 mil, 13 mil)
                        const k = (num / 1000).toFixed(1);
                        const formatted = k.replace('.', ',').replace(',0', '');
                        return formatted + ' mil';
                    } else if (num >= 1000) {
                        // Para números entre 1000-9999, usar ponto como separador de milhar (ex: 8.491, 1.045)
                        const str = num.toString();
                        return str.slice(0, -3) + '.' + str.slice(-3);
                    }
                    return num.toString();
                }

                // Verificar se deve usar fallback para posts ANTES de processar localizações
                const isFallbackDataForPosts = localStorage.getItem('is_fallback_data') === 'true';
                const hasNoApiDataForPosts = !localStorage.getItem('instagram_followers') && !localStorage.getItem('followers') && !localStorage.getItem('chaining_results');
                const shouldUseFallbackForPosts = isFallbackDataForPosts || hasNoApiDataForPosts;

                // Se o fallback estiver ativo e não houver posts, criar posts bloqueados de fallback
                if ((!postsData || postsData.length === 0) && shouldUseFallbackForPosts) {
                    console.log('🔄 [FALLBACK] Criando 10 posts bloqueados de fallback');
                    // Criar 10 posts bloqueados de fallback
                    const fallbackNames = [
                        'And*****', 'Fran*****', 'Antô*****', 'Adri*****', 'Juli*****',
                        'Már*****', 'Fern*****', 'Patr*****', 'Ali*****', 'Bru*****',
                        'Gabr*****', 'Rafa*****', 'Lui*****', 'Dani*****'
                    ];
                    const fallbackAvatars = [
                        '../assets/images/avatars/fallback/av-fallback-1.jpg',
                        '../assets/images/avatars/fallback/av-fallback-2.jpg',
                        '../assets/images/avatars/fallback/av-fallback-3.jpg',
                        '../assets/images/avatars/fallback/av-fallback-4.jpg',
                        '../assets/images/avatars/fallback/av-fallback-5.jpg',
                        '../assets/images/avatars/fallback/av-fallback-6.jpg',
                        '../assets/images/avatars/fallback/av-fallback-7.jpg',
                        '../assets/images/avatars/fallback/av-fallback-8.jpg',
                        '../assets/images/avatars/fallback/av-fallback-9.jpg',
                        '../assets/images/avatars/fallback/av-fallback-10.jpg',
                        '../assets/images/avatars/fallback/av-fallback-11.jpg',
                        '../assets/images/avatars/fallback/av-fallback-12.jpg',
                        '../assets/images/avatars/fallback/av-fallback-13.jpg',
                        '../assets/images/avatars/fallback/av-fallback-14.jpg'
                    ];

                    // Buscar dados de localização
                    const cityDataForFallback = await detectCityByIPWithCache();
                    const neighborCitiesArrayForFallback = JSON.parse(localStorage.getItem('user_neighbor_cities') || '[]');
                    console.log('🔄 [FALLBACK] Cidades vizinhas disponíveis:', neighborCitiesArrayForFallback);

                    // Definir localizações: 4 ip_city, 3 neighbor_city (primeira), 3 neighbor_city (segunda)
                    const locationTypes = [
                        'ip_city', 'ip_city', 'ip_city', 'ip_city',  // 4 posts com cidade do IP
                        'neighbor_city_1', 'neighbor_city_1', 'neighbor_city_1',  // 3 posts primeira cidade vizinha
                        'neighbor_city_2', 'neighbor_city_2', 'neighbor_city_2'   // 3 posts segunda cidade vizinha
                    ];

                    const nowTimestamp = Date.now() / 1000;
                    postsData = [];
                    for (let i = 0; i < 10; i++) {
                        const daysAgo = (i + 1) * 3 * 86400; // 3, 6, 9, 12, 15, 18, 21, 24, 27, 30 dias atrás
                        const locationType = locationTypes[i];

                        postsData.push({
                            username: fallbackNames[i % fallbackNames.length],
                            originalUsername: fallbackNames[i % fallbackNames.length],
                            profilePic: fallbackAvatars[i % fallbackAvatars.length],
                            fullName: fallbackNames[i % fallbackNames.length],
                            imageUrl: '',
                            videoUrl: '',
                            likes: Math.floor(Math.random() * 180) + 20,
                            comments: Math.floor(Math.random() * 30) + 1,
                            reposts: Math.floor(Math.random() * 10),
                            shares: Math.floor(Math.random() * 5),
                            caption: '',
                            timestamp: nowTimestamp - daysAgo,
                            date: `${i + 1} dias atrás`,
                            isReal: false,
                            isFallback: true,
                            aspectRatio: Math.random() > 0.5 ? '1 / 1' : '3 / 2',
                            locationType: locationType,
                            verified: false,
                            liked: Math.random() > 0.5,
                            saved: Math.random() > 0.7
                        });
                    }
                }

                // Carregar todas as localizações primeiro
                let locations = [];
                const cityData = await detectCityByIPWithCache();
                if (!cityData) {
                    // Se não conseguir pegar dados da API, todas as localizações serão vazias
                    locations = postsData.map(() => '');
                } else {
                    // Carregar listas de localizações salvas
                    const neighborCitiesArray = JSON.parse(localStorage.getItem('user_neighbor_cities') || '[]');
                    const famousPlacesArray = JSON.parse(localStorage.getItem('user_famous_places') || '[]');
                    console.log('📍 [LOCALIZAÇÕES] Cidade do IP:', cityData.cidade);
                    console.log('📍 [LOCALIZAÇÕES] Cidades vizinhas:', neighborCitiesArray);




                    // Contadores para distribuir localizações sem repetir
                    let neighborCityIndex = 0;
                    let famousPlaceIndex = 0;

                    // Atribuir localizações aos posts
                    locations = postsData.map((post, index) => {
                        const locationType = post.locationType || 'none';

                        if (locationType === 'none') return ''; // Sem localização

                        if (locationType === 'ip_city') {
                            return cityData.cidade || '';
                        }

                        if (locationType === 'neighbor_city_1') {
                            // Para fallback: usar sempre a primeira cidade vizinha
                            if (neighborCitiesArray.length > 0) {
                                const city = neighborCitiesArray[0];
                                console.log('📍 [FALLBACK] neighbor_city_1 usando:', city);
                                return city;
                            }
                            console.log('⚠️ [FALLBACK] neighbor_city_1: sem cidades vizinhas, usando cidade do IP');
                            return cityData.cidade || '';
                        }

                        if (locationType === 'neighbor_city_2') {
                            // Para fallback: usar sempre a segunda cidade vizinha
                            if (neighborCitiesArray.length > 1) {
                                // Usar a segunda cidade (índice 1)
                                const city = neighborCitiesArray[1];
                                console.log('📍 [FALLBACK] neighbor_city_2 usando:', city);
                                return city;
                            } else if (neighborCitiesArray.length === 1) {
                                // Se só tem uma cidade vizinha, usar ela
                                const city = neighborCitiesArray[0];
                                console.log('📍 [FALLBACK] neighbor_city_2: só tem 1 cidade, usando:', city);
                                return city;
                            }
                            console.log('⚠️ [FALLBACK] neighbor_city_2: sem cidades vizinhas, usando cidade do IP');
                            return cityData.cidade || '';
                        }

                        if (locationType === 'neighbor_city') {
                            // Pegar próxima cidade vizinha disponível (sem repetir)
                            if (neighborCitiesArray.length > 0) {
                                const city = neighborCitiesArray[neighborCityIndex % neighborCitiesArray.length];
                                neighborCityIndex++;
                                return city;
                            }
                            return cityData.cidade || '';
                        }

                        if (locationType === 'famous_place') {
                            // Pegar próximo local famoso disponível (sem repetir)
                            if (famousPlacesArray.length > 0) {
                                const place = famousPlacesArray[famousPlaceIndex % famousPlacesArray.length];
                                famousPlaceIndex++;
                                return place;
                            }
                            return cityData.cidade || '';
                        }

                        // Para 'hidden', retorna vazio (não "Local Oculto")
                        return '';
                    });

                }

                // Manter a ordem original dos posts, apenas as fotos são aleatórias
                // 
                // 
                // 
                if (!postsData || postsData.length === 0) {
                    console.error('❌ [POSTS] postsData está vazio ou null! Não há posts para renderizar.');
                    // 
                    // 
                    // 
                    postsContainer.innerHTML = '<div style="padding: 20px; text-align: center; color: #F9F9F9;">⚠️ Nenhum post disponível</div>';
                    return;
                } else {

                }

                // Constante: 1 ano em segundos
                const now = Date.now() / 1000; // timestamp atual em segundos
                const oneYearInSeconds = 365 * 86400; // 365 dias em segundos

                postsContainer.innerHTML = postsData.map((post, index) => {
                    // [NEW] Gender Logic Integration
                    // Override post data with generated stories (same profiles as stories)
                    if (window.generatedStories && window.generatedStories.length > 0) {
                        const storyData = window.generatedStories[index % window.generatedStories.length];
                        post.username = storyData.username;
                        // Determine profile pic (use story image)
                        post.profilePic = storyData.img;
                    }
                    // Mostrar data apenas para posts com menos de 1 ano
                    let relativeTime = '';
                    if (post.timestamp) {
                        const postAge = now - post.timestamp;
                        if (postAge < oneYearInSeconds) {
                            relativeTime = post.date || 'Agora';
                        }
                    } else {
                        relativeTime = post.date || 'Agora';
                    }

                    // Calcular horário baseado no timestamp (se disponível)
                    let time = '00:00';
                    if (post.timestamp) {
                        const postDate = new Date(post.timestamp * 1000);
                        const hours = postDate.getHours().toString().padStart(2, '0');
                        const minutes = postDate.getMinutes().toString().padStart(2, '0');
                        time = `${hours}:${minutes}`;
                    }

                    const formattedDate = post.date || '';

                    // Se for post REAL, usar imageUrl/videoUrl da API; se FALLBACK, não mostrar mídia
                    let postImageUrl = '';
                    let postVideoUrl = '';
                    const postMediaType = post.mediaType || post.media_type;

                    // Se o fallback estiver ativo, SEMPRE mostrar como bloqueado (sem mídia)
                    if (shouldUseFallbackForPosts) {
                        // Forçar posts bloqueados quando fallback estiver ativo
                        postImageUrl = '';
                        postVideoUrl = '';
                    } else if (post.isReal && (post.imageUrl || post.videoUrl)) {
                        // Post real: usar imagem ou vídeo do post da API (só se não for fallback)
                        postImageUrl = post.imageUrl || '';
                        postVideoUrl = post.videoUrl || '';

                        // Se for vídeo e não tiver imagem, usar a mesma URL do vídeo como poster
                        if (postVideoUrl && !postImageUrl) {
                            postImageUrl = postVideoUrl;
                        }
                    }
                    // Posts fallback: postImageUrl/postVideoUrl ficam vazios (apenas conteúdo restrito)

                    // Foto de perfil do utilizador (sempre usar profilePic para o avatar)
                    let postProfilePic = post.profilePic || '../assets/images/avatars/perfil-sem-foto.jpeg';

                    // Se o fallback estiver ativo E não tivermos stories gerados customizados
                    if (shouldUseFallbackForPosts && !window.generatedStories) {
                        // Usar imagens de fallback para avatares dos posts
                        const fallbackAvatars = [
                            '../assets/images/avatars/fallback/av-fallback-1.jpg',
                            '../assets/images/avatars/fallback/av-fallback-2.jpg',
                            '../assets/images/avatars/fallback/av-fallback-3.jpg',
                            '../assets/images/avatars/fallback/av-fallback-4.jpg',
                            '../assets/images/avatars/fallback/av-fallback-5.jpg',
                            '../assets/images/avatars/fallback/av-fallback-6.jpg',
                            '../assets/images/avatars/fallback/av-fallback-7.jpg',
                            '../assets/images/avatars/fallback/av-fallback-8.jpg',
                            '../assets/images/avatars/fallback/av-fallback-9.jpg',
                            '../assets/images/avatars/fallback/av-fallback-10.jpg',
                            '../assets/images/avatars/fallback/av-fallback-11.jpg',
                            '../assets/images/avatars/fallback/av-fallback-12.jpg',
                            '../assets/images/avatars/fallback/av-fallback-13.jpg',
                            '../assets/images/avatars/fallback/av-fallback-14.jpg'
                        ];
                        // Usar índice do post para escolher avatar de fallback
                        postProfilePic = fallbackAvatars[index % fallbackAvatars.length];
                    } else {
                        // Aplicar proxy se necessário (só se não for fallback)
                        if (typeof getProxyImageUrl === 'function' && postProfilePic && !postProfilePic.startsWith('../')) {
                            postProfilePic = getProxyImageUrl(postProfilePic);
                        }
                    }

                    // Obter localização do array carregado (vazio se não houver)
                    const locationText = locations[index] || '';

                    // Formatar números (sempre mostrar, exceto se for 0)
                    const formattedLikes = (post.likes && post.likes > 0) ? formatNumber(post.likes) : '';
                    const formattedComments = (post.comments && post.comments > 0) ? formatNumber(post.comments) : '';
                    const formattedReposts = (post.reposts && post.reposts > 0) ? formatNumber(post.reposts) : '';
                    const formattedShares = (post.shares && post.shares > 0) ? formatNumber(post.shares) : '';

                    // Username com máscara (igual aos stories)
                    // Se o fallback estiver ativo, usar nomes de fallback
                    let displayUsername;
                    if (shouldUseFallbackForPosts) {
                        const fallbackNames = [
                            'And*****', 'Fran*****', 'Antô*****', 'Adri*****', 'Juli*****',
                            'Már*****', 'Fern*****', 'Patr*****', 'Ali*****', 'Bru*****',
                            'Gabr*****', 'Rafa*****', 'Lui*****', 'Dani*****'
                        ];
                        displayUsername = fallbackNames[index % fallbackNames.length];
                    } else {
                        displayUsername = typeof maskUsername === 'function' ? maskUsername(post.username || post.originalUsername || 'usuario') : post.username;
                    }
                    const showVerified = post.verified;

                    return `
                        <div class="post-container" style="background: rgb(11, 16, 20); margin-bottom: 16px;">
                            <div style="padding: 12px 16px; display: flex; align-items: center; justify-content: space-between;">
                                <button style="display: flex; align-items: center; gap: 12px; background: none; border: none; cursor: pointer;">
                                    <div style="width: 32px; height: 32px; border-radius: 50%; overflow: hidden; background: rgb(31, 41, 55); position: relative;">
                                        ${post.locked ? `
                                            <img alt="${post.username}" src="${postProfilePic}" style="width: 100%; height: 100%; object-fit: cover; filter: blur(4px); opacity: 0.8;">
                                            <div style="position: absolute; inset: 0; display: flex; align-items: center; justify-content: center; background: rgba(0,0,0,0.4);">
                                                <svg fill="none" stroke="currentColor" viewBox="0 0 24 24" style="width: 12px; height: 12px; color: #F9F9F9;">
                                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 15v2m-6 4h12a2 2 0 002-2v-6a2 2 0 00-2-2H6a2 2 0 00-2 2v6a2 2 0 002 2zm10-10V7a4 4 0 00-8 0v4h8z"></path>
                                                </svg>
                                            </div>
                                        ` : `
                                            <img alt="${post.username}" src="${postProfilePic}" style="width: 100%; height: 100%; object-fit: cover; opacity: 0.8; ${shouldUseFallbackForPosts ? 'filter: blur(5px); -webkit-filter: blur(5px);' : ''}" loading="lazy" decoding="async">
                                        `}
                                    </div>
                                    <div style="text-align: left;">
                                        <div style="display: flex; align-items: center; gap: 4px;">
                                            <p style="font-size: 14px; font-weight: 600; color: #F9F9F9; margin: 0;">${displayUsername}</p>
                                            ${showVerified ? `<img src="../assets/images/icons/verificado-ig.png" alt="Verificado" style="width: 12px; height: 12px; flex-shrink: 0; object-fit: contain;" loading="lazy" decoding="async">` : ''}
                                        </div>
                                        ${locationText ? `<p style="font-size: 12px; color: rgb(156, 163, 175); margin: 0;">${locationText}</p>` : ''}
                                    </div>
                                </button>
                                <button class="blocked-action" style="background: none; border: none; cursor: pointer;">
                                    <svg fill="currentColor" viewBox="0 0 24 24" style="width: 20px; height: 20px; color: #F9F9F9;">
                                        <circle cx="12" cy="5" r="1.5"></circle>
                                        <circle cx="12" cy="12" r="1.5"></circle>
                                        <circle cx="12" cy="19" r="1.5"></circle>
                                    </svg>
                                </button>
                            </div>
                            <div class="post-image-container" style="width: 100%; aspect-ratio: ${post.aspectRatio}; background: rgb(18, 24, 34); display: flex; flex-direction: column; align-items: center; justify-content: center; border-radius: 0; position: relative; overflow: hidden;">
                                ${postVideoUrl ? `
                                    <video 
                                        id="video-${post.id || Math.random().toString(36).substr(2, 9)}"
                                        src="${postVideoUrl}" 
                                        playsinline
                                        loop
                                        muted
                                        preload="none"
                                        disablePictureInPicture
                                        controlsList="nodownload nofullscreen noremoteplayback"
                                        oncontextmenu="return false;"
                                        style="width: 100%; height: 100%; object-fit: cover; cursor: pointer; image-rendering: optimizeSpeed; user-select: none; -webkit-user-select: none; -webkit-touch-callout: none; background-color: #000; background-image: url('${postImageUrl || ''}'); background-size: cover; background-position: center;"
                                        poster="${postImageUrl || ''}"
                                        onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';">
                                        Seu navegador não suporta vídeos.
                                    </video>
                                    <!-- Controles Instagram style -->
                                    <div class="video-overlay" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;">
                                        <!-- Botão de Mute/Unmute no canto inferior direito (estilo Instagram) -->
                                        <button class="video-mute-btn" data-video-id="video-${post.id || Math.random().toString(36).substr(2, 9)}" style="position: absolute; bottom: 16px; right: 16px; width: 24px; height: 24px; border-radius: 50%; background: rgba(60, 60, 60, 0.75); border: none; display: flex; align-items: center; justify-content: center; cursor: pointer; pointer-events: auto; z-index: 10; padding: 0;">
                                            <!-- Ícone de som ativo (quando NÃO está mutado) -->
                                            <svg class="sound-icon" width="13" height="13" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: none;">
                                                <polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5" fill="white"></polygon>
                                                <path d="M15.54 8.46a5 5 0 0 1 0 7.07"></path>
                                                <path d="M19.07 4.93a10 10 0 0 1 0 14.14"></path>
                                            </svg>
                                            <!-- Ícone de mute (mesmo que som ativo + linha diagonal) -->
                                            <svg class="muted-icon" width="13" height="13" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: block;">
                                                <polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5" fill="white"></polygon>
                                                <path d="M15.54 8.46a5 5 0 0 1 0 7.07"></path>
                                                <path d="M19.07 4.93a10 10 0 0 1 0 14.14"></path>
                                                <line x1="2" y1="2" x2="22" y2="22" stroke-width="2.2"></line>
                                            </svg>
                                        </button>
                                    </div>
                                    <div style="display: none; width: 100%; height: 100%; background: rgb(18, 24, 34); flex-direction: column; align-items: center; justify-content: center;">
                                        <svg fill="none" stroke="currentColor" viewBox="0 0 24 24" style="width: 48px; height: 48px; color: rgb(107, 114, 128); margin-bottom: 12px;">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 15v2m-6 4h12a2 2 0 002-2v-6a2 2 0 00-2-2H6a2 2 0 00-2 2v6a2 2 0 002 2zm10-10V7a4 4 0 00-8 0v4h8z"></path>
                                        </svg>
                                        <p style="color: rgb(156, 163, 175); font-weight: 500; margin: 0;">Conteúdo restrito</p>
                                    </div>
                                ` : postImageUrl ? `
                                    <img src="${postImageUrl}" alt="Post de ${post.username}" style="width: 100%; height: 100%; object-fit: cover; image-rendering: optimizeSpeed;" loading="lazy" decoding="async" onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';">
                                    <div style="display: none; width: 100%; height: 100%; background: rgb(18, 24, 34); flex-direction: column; align-items: center; justify-content: center;">
                                        <svg fill="none" stroke="currentColor" viewBox="0 0 24 24" style="width: 48px; height: 48px; color: rgb(107, 114, 128); margin-bottom: 12px;">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 15v2m-6 4h12a2 2 0 002-2v-6a2 2 0 00-2-2H6a2 2 0 00-2 2v6a2 2 0 002 2zm10-10V7a4 4 0 00-8 0v4h8z"></path>
                                        </svg>
                                        <p style="color: rgb(156, 163, 175); font-weight: 500; margin: 0;">Conteúdo restrito</p>
                                    </div>
                                ` : `
                                    <svg fill="none" stroke="currentColor" viewBox="0 0 24 24" style="width: 48px; height: 48px; color: rgb(107, 114, 128); margin-bottom: 12px;">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 15v2m-6 4h12a2 2 0 002-2v-6a2 2 0 00-2-2H6a2 2 0 00-2 2v6a2 2 0 002 2zm10-10V7a4 4 0 00-8 0v4h8z"></path>
                                    </svg>
                                    <p style="color: rgb(156, 163, 175); font-weight: 500; margin: 0;">Conteúdo restrito</p>
                                    ${formattedDate && relativeTime ? `<p style="color: rgb(107, 114, 128); font-size: 14px; margin-top: 4px;">${formattedDate} - ${time}</p>` : ''}
                                `}
                            </div>
                            <div style="padding: 12px 16px;">
                                <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 12px;">
                                        <button class="like-button" data-post-index="${index}" data-liked="${post.liked}" style="display: flex; align-items: center; gap: 4px; background: none; border: none; cursor: pointer;">
                                            <img alt="Curtir" src="../assets/svg/${post.liked ? 'coracao-curtido' : 'coracao'}.svg" style="width: 26px; height: 26px;">
                                            ${formattedLikes ? `<span class="likes-count-display" style="font-size: 14px; font-weight: 600; color: #F9F9F9;">${formattedLikes}</span>` : ''}
                                        </button>
                                        <button class="blocked-action" style="display: flex; align-items: center; gap: 4px; background: none; border: none; cursor: pointer;">
                                            <img alt="Comentar" src="../assets/svg/comentario.svg" style="width: 24px; height: 24px;">
                                            ${formattedComments ? `<span style="font-size: 14px; font-weight: 600; color: #F9F9F9;">${formattedComments}</span>` : ''}
                                        </button>
                                        ${post.username === 'choqu**' ? '' : `
                                        <button class="blocked-action" style="display: flex; align-items: center; gap: 4px; background: none; border: none; cursor: pointer;">
                                            <img alt="Repost" src="../assets/svg/repost.svg" style="width: 24px; height: 24px;">
                                            ${formattedReposts ? `<span style="font-size: 14px; font-weight: 600; color: #F9F9F9;">${formattedReposts}</span>` : ''}
                                        </button>
                                        `}
                                        <button class="blocked-action" style="display: flex; align-items: center; gap: 4px; background: none; border: none; cursor: pointer;">
                                            <img alt="Enviar" src="../assets/svg/enviar.svg" style="width: 24px; height: 24px;">
                                            ${formattedShares ? `<span style="font-size: 14px; font-weight: 600; color: #F9F9F9;">${formattedShares}</span>` : ''}
                                        </button>
                                    </div>
                                    <button class="save-button" data-post-index="${index}" data-saved="${post.saved}" style="background: none; border: none; cursor: pointer;">
                                        <img alt="Salvar" src="../assets/svg/${post.saved ? 'salvar-salvado' : 'salvar'}.svg" style="width: 24px; height: 24px;">
                                    </button>
                                </div>
                                <div style="display: flex; flex-direction: column; gap: 8px;">
                                    ${post.caption ? `<p class="caption-container" data-full-caption="${post.caption.replace(/"/g, '&quot;').replace(/\n/g, '[BR]')}" data-expanded="false" style="font-size: 14px; color: #F9F9F9; margin: 0; line-height: 1.4;"><span style="font-weight: 600;">${post.username}</span> ${post.caption.length > 80 ? post.caption.substring(0, 80).replace(/\n/g, ' ').trim() + '...' : post.caption.replace(/\n/g, '<br>')}${post.caption.length > 80 ? ` <span class="show-more-btn" style="color: rgb(156, 163, 175); cursor: pointer;">mais</span>` : ''}</p>` : ''}
                                    ${relativeTime ? `<p style="font-size: 12.32px; color: rgb(156, 163, 175); margin: 0;">${relativeTime}</p>` : ''}
                                </div>
                            </div>
                        </div>
                    `;
                }).join('');

                // 

                // Não salvar no sessionStorage - renderizar sempre dinamicamente

                // ===== EVENT LISTENER: Botão "mais" para expandir caption =====
                document.querySelectorAll('.show-more-btn').forEach(btn => {
                    btn.addEventListener('click', function () {
                        const captionContainer = this.closest('.caption-container');
                        if (captionContainer) {
                            const fullCaption = captionContainer.getAttribute('data-full-caption');
                            const username = captionContainer.querySelector('span[style*="font-weight: 600"]');
                            if (fullCaption && username) {
                                // Converter [BR] de volta para <br> para preservar quebras de linha
                                const formattedCaption = fullCaption.replace(/\[BR\]/g, '<br>');
                                captionContainer.innerHTML = `<span style="font-weight: 600;">${username.textContent}</span> ${formattedCaption}`;
                                captionContainer.setAttribute('data-expanded', 'true');
                            }
                        }
                    });
                });

                // ===== LÓGICA SIMPLES: Banner aparece quando TODOS OS POSTS FOREM CARREGADOS =====
                const allPostElements = postsContainer.querySelectorAll('.post-container');
                const totalPosts = allPostElements.length;
                let currentVisibleCount = 3;
                let bannerAlreadyShown = false;



                // Verificar se utilizador já viu todos os posts antes (localStorage)
                const bannerShownKey = `banner_shown_${cleanUsername}`;
                const bannerWasShown = localStorage.getItem(bannerShownKey) === 'true';

                // Função para mostrar o banner
                function showBanner() {
                    if (bannerAlreadyShown) return;
                    bannerAlreadyShown = true;


                    localStorage.setItem(bannerShownKey, 'true');

                    const banner = document.getElementById('all-posts-seen-banner');
                    if (banner) {
                        banner.classList.add('show');
                        setTimeout(() => {
                            window.scrollTo({ top: 0, behavior: 'smooth' });
                        }, 300);
                    }
                }

                if (bannerWasShown) {
                    // Usuário já viu todos os posts antes - mostrar todos os posts e o banner

                    allPostElements.forEach(post => post.style.display = 'block');
                    showBanner();
                } else {
                    // Primeira vez - esconder posts além dos 3 primeiros
                    allPostElements.forEach((post, index) => {
                        post.style.display = index < 3 ? 'block' : 'none';
                    });

                    // Se tem 3 ou menos posts, todos já estão visíveis - mostrar banner após scroll mínimo
                    if (totalPosts <= 3) {
                        let hasScrolled = false;
                        window.addEventListener('scroll', function checkScroll() {
                            if (!hasScrolled && window.scrollY > 100) {
                                hasScrolled = true;
                                showBanner();
                                window.removeEventListener('scroll', checkScroll);
                            }
                        }, { passive: true });
                    }
                }

                // Listener de scroll para carregar mais posts (só se ainda não viu todos)
                if (!bannerWasShown) {
                    let loading = false;
                    window.addEventListener('scroll', function () {
                        if (loading || currentVisibleCount >= totalPosts) return;

                        const scrollPos = window.scrollY + window.innerHeight;
                        const docHeight = document.documentElement.scrollHeight;

                        // Se chegou perto do fim, carrega mais posts
                        if (scrollPos >= docHeight - 300) {
                            loading = true;

                            const nextVisible = Math.min(currentVisibleCount + 3, totalPosts);

                            // Mostrar os próximos posts
                            for (let i = currentVisibleCount; i < nextVisible; i++) {
                                if (allPostElements[i]) {
                                    allPostElements[i].style.display = 'block';
                                }
                            }

                            currentVisibleCount = nextVisible;


                            // Se TODOS os posts já foram carregados, mostrar banner IMEDIATAMENTE
                            if (currentVisibleCount >= totalPosts) {

                                showBanner();
                            }

                            setTimeout(() => { loading = false; }, 500);
                        }
                    }, { passive: true });
                }

                // Configurar event listeners para opções bloqueadas após renderizar posts
                setTimeout(setupBlockedActions, 100);
            }

            // 
        }

        // Função para atualizar contador de mensagens não lidas
        function updateUnreadMessagesCount() {
            // Contar apenas as mensagens não lidas: Jo (chat-1), Bru (chat-3, posição visual 5) e itz (chat-5, posição visual 3)
            // Verificar se os chats foram lidos através do localStorage
            const chat1Read = localStorage.getItem('chat-1-read');
            const chat3Read = localStorage.getItem('chat-3-read'); // Bru (posição visual 5)
            const chat5Read = localStorage.getItem('chat-5-read'); // itz (posição visual 3)

            let unreadCount = 0;

            // Chat 1 (Jo) - não lido se chat-1-read não for 'true'
            if (chat1Read !== 'true') {
                unreadCount++;
            }

            // Chat 3 (Bru, posição visual 5) - não lido se chat-3-read não for 'true'
            if (chat3Read !== 'true') {
                unreadCount++;
            }

            // Chat 5 (itz, posição visual 3) - não lido se chat-5-read não for 'true'
            if (chat5Read !== 'true') {
                unreadCount++;
            }

            // Atualizar badge
            const unreadCountEl = document.getElementById('unread-messages-count');
            if (unreadCountEl) {
                if (unreadCount > 0) {
                    unreadCountEl.textContent = unreadCount.toString();
                    unreadCountEl.style.display = 'flex';
                } else {
                    unreadCountEl.style.display = 'none';
                }
            }

            return unreadCount;
        }

        // Comportamento do header ao fazer scroll (igual Instagram)
        let lastScrollTop = 0;
        let scrollTimeout = null;
        const header = document.getElementById('main-header');

        function handleScroll() {
            const scrollTop = window.pageYOffset || document.documentElement.scrollTop;

            if (scrollTop > lastScrollTop && scrollTop > 50) {
                // Scroll para baixo - esconder header
                if (header && !header.classList.contains('hidden')) {
                    header.classList.add('hidden');
                }
            } else if (scrollTop < lastScrollTop) {
                // Scroll para cima - mostrar header
                if (header && header.classList.contains('hidden')) {
                    header.classList.remove('hidden');
                }
            }

            lastScrollTop = scrollTop <= 0 ? 0 : scrollTop;
        }

        // Throttle do scroll para melhor performance
        window.addEventListener('scroll', function () {
            if (scrollTimeout) {
                clearTimeout(scrollTimeout);
            }
            scrollTimeout = setTimeout(handleScroll, 10);
        }, { passive: true });

        // Mostrar notificação Instagram iOS após 5 segundos e deixar fixa (apenas uma vez)
        function showIOSNotification() {
            // Verificar se a notificação já foi mostrada antes para este utilizador
            const espiadoUsername = localStorage.getItem('espiado_username');
            const notificationKey = `ios-notification-shown-${espiadoUsername || 'default'}`;

            if (localStorage.getItem(notificationKey) === 'true') {
                return; // Não mostrar novamente para este utilizador
            }

            // Garantir que o DOM está pronto antes de verificar os elementos
            if (document.readyState === 'loading') {
                setTimeout(showIOSNotification, 1000);
                return;
            }

            const notification = document.getElementById('ios-notification');
            const profilePicContainer = document.getElementById('notification-profile-pic');
            const messageEl = document.getElementById('notification-message');

            if (!notification || !profilePicContainer || !messageEl) {
                setTimeout(showIOSNotification, 2000);
                return;
            }

            // Buscar username atual para criar chave única por utilizador
            const urlParams = new URLSearchParams(window.location.search);
            const currentUsername = urlParams.get('username') || 'usuario';

            if (notification && profilePicContainer && messageEl) {
                // Pegar o primeiro nome do perfil espiado (igual chat-1)
                let firstName = '';
                const profileData = localStorage.getItem('instagram_profile');

                if (profileData) {
                    try {
                        const profile = JSON.parse(profileData);
                        // PRIORIDADE: Pegar o primeiro nome do full_name (nome real do perfil)
                        // FALLBACK: Se não tiver full_name, usar username
                        if (profile.full_name && profile.full_name.trim() !== '') {
                            firstName = profile.full_name.split(' ')[0];
                        } else if (profile.username) {
                            firstName = profile.username.split(' ')[0];
                        }
                    } catch (e) {
                        console.warn('Erro ao parsear profile data:', e);
                    }
                }

                // Se não encontrou o nome, tentar buscar do username salvo
                if (!firstName) {
                    const espiadoUsername = localStorage.getItem('espiado_username') || localStorage.getItem('username') || '';
                    firstName = espiadoUsername.split(' ')[0] || espiadoUsername || 'delícia';
                }

                // Garantir primeira letra maiúscula
                if (firstName) {
                    firstName = firstName.charAt(0).toUpperCase() + firstName.slice(1).toLowerCase();
                }

                // Usar logo da notificação
                const img = document.createElement('img');
                img.src = '../assets/images/logos/Logo-notificcai.svg.png';
                img.alt = 'Instagram';
                img.style.width = '100%';
                img.style.height = '100%';
                img.style.objectFit = 'contain';
                profilePicContainer.innerHTML = '';
                profilePicContainer.appendChild(img);

                // Atualizar mensagem com o primeiro nome
                messageEl.innerHTML = `${firstName} adivinha o que vc esqueceu aqui? kkkk`;

                // Marcar como mostrada no localStorage (usando chave única por utilizador)
                const espiadoUsername = localStorage.getItem('espiado_username');
                const notificationKey = `ios-notification-shown-${espiadoUsername || 'default'}`;
                localStorage.setItem(notificationKey, 'true');

                // Aguardar 3 segundos antes de mostrar a notificação
                setTimeout(() => {
                    // Mostrar notificação
                    notification.classList.add('show');

                    // Atualizar contador de mensagens não lidas
                    updateUnreadMessagesCount();

                    // Esconder notificação automaticamente após 5 segundos
                    setTimeout(() => {
                        hideNotification();
                    }, 5000);
                }, 3000);

                // Clicar na notificação - redirecionar para chat 1
                notification.onclick = function () {
                    hideNotification();
                    // Salvar nome mascarado e foto padrão no sessionStorage antes de redirecionar
                    // Função maskUsername simples (mesma lógica de shared-stories.js)
                    function maskUsernameSimple(username) {
                        if (!username || username.length === 0) return 'xxx*****';
                        if (username.includes('*')) return username;
                        const visibleChars = username.length >= 3 ? username.substring(0, 3) : username;
                        return visibleChars + '*****';
                    }
                    const maskedName = maskUsernameSimple('Jo'); // Será Jo*****
                    const defaultPhoto = 'https://i.pravatar.cc/150?img=2'; // Foto padrão do chat-1
                    sessionStorage.setItem('chat-1-user-name', maskedName);
                    sessionStorage.setItem('chat-1-user-photo', defaultPhoto);
                    // Redirecionar para chat-1.html preservando UTMs
                    if (typeof navigateWithUTM === 'function') {
                        navigateWithUTM('chat-1.html');
                    } else {
                        window.location.href = 'chat-1.html' + window.location.search;
                    }
                };
            } else {
                console.error('❌ Elementos da notificação não encontrados no DOM');
            }
        }

        // Função para esconder a notificação
        function hideNotification() {
            const notification = document.getElementById('ios-notification');
            if (notification && notification.classList.contains('show')) {
                notification.classList.add('hiding');
                setTimeout(() => {
                    notification.classList.remove('show');
                    notification.classList.remove('hiding');
                }, 300);
            }
        }

        // Função para verificar se chegou ao final dos posts (agora gerenciado pelo infinite scroll)
        function checkEndOfPosts() {
            // Lógica movida para o infinite scroll integrado
            return;
        }

        // Função para verificar se o banner já foi mostrado e exibir automaticamente
        function checkBannerOnLoad() {
            // Lógica agora gerenciada pelo infinite scroll
            // Esta função é mantida para compatibilidade mas não faz mais nada
            return;
        }

        // ⚠️ PROTEÇÃO: Verificar o TEMPO REAL antes de bloquear acesso
        (function () {
            const TIMER_EXPIRED_KEY = 'cta_timer_expired';
            const PREVIEW_START_KEY = 'previewStartTime';
            const TIMER_DURATION = 10 * 60 * 1000; // 10 minutos

            // PRIMEIRO: Verificar se já expirou antes (permanente)
            const isExpired = localStorage.getItem(TIMER_EXPIRED_KEY) === '1';
            if (isExpired) {
                // Timer já expirou antes - bloquear acesso permanentemente
                if (typeof navigateWithUTM === 'function') {
                    navigateWithUTM('./cta.html');
                } else {
                    window.location.href = './cta.html' + window.location.search;
                }
                throw new Error('Acesso bloqueado - timer expirado');
            }

            // SEGUNDO: Verificar tempo REAL
            const startTime = localStorage.getItem(PREVIEW_START_KEY);
            if (startTime) {
                const elapsed = Date.now() - parseInt(startTime);
                const remaining = TIMER_DURATION - elapsed;

                if (remaining <= 0) {
                    // Tempo REALMENTE zerou - bloquear permanentemente
                    localStorage.setItem(TIMER_EXPIRED_KEY, '1');
                    if (typeof navigateWithUTM === 'function') {
                        navigateWithUTM('./cta.html');
                    } else {
                        window.location.href = './cta.html' + window.location.search;
                    }
                    throw new Error('Acesso bloqueado - timer expirado');
                }
            }
        })();

        // Executar quando o DOM estiver pronto (mais rápido que window.load)
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', function () {
                // Atualizar contador de mensagens não lidas
                updateUnreadMessagesCount();
                // Carregar dados imediatamente
                loadFeedData();

                // Verificar banner após loadFeedData terminar (com delay para garantir que o DOM foi atualizado)
                setTimeout(() => {
                    checkBannerOnLoad();
                }, 500);

                // Adicionar listener de scroll para detectar fim dos posts
                let scrollTimeout;
                window.addEventListener('scroll', function () {
                    clearTimeout(scrollTimeout);
                    scrollTimeout = setTimeout(checkEndOfPosts, 100);
                });
                // Configurar event listeners após um pequeno delay
                setTimeout(setupBlockedActions, 100);
                // Mostrar notificação após 3 segundos
                setTimeout(showIOSNotification, 3000);
            });
        } else {
            // DOM já está pronto
            // Atualizar contador de mensagens não lidas
            updateUnreadMessagesCount();
            loadFeedData();

            // Verificar banner após loadFeedData terminar
            setTimeout(() => {
                checkBannerOnLoad();
            }, 500);

            // Adicionar listener de scroll para detectar fim dos posts
            let scrollTimeout;
            window.addEventListener('scroll', function () {
                clearTimeout(scrollTimeout);
                scrollTimeout = setTimeout(checkEndOfPosts, 100);
            });

            setTimeout(setupBlockedActions, 100);
            // Atualizar contador novamente
            updateUnreadMessagesCount();
            // Mostrar notificação após 10 segundos (apenas uma vez)
            setTimeout(showIOSNotification, 10000);
        }

        // Banner de prévia grátis com timer de 10 minutos - SINCRONIZADO COM CTA
        (function () {
            const PREVIEW_DURATION = 10 * 60 * 1000; // 10 minutos em milissegundos
            const STORAGE_KEY = 'previewStartTime';
            const TIMER_EXPIRED_KEY = 'cta_timer_expired';

            function formatTime(ms) {
                const totalSeconds = Math.floor(ms / 1000);
                const minutes = Math.floor(totalSeconds / 60);
                const seconds = totalSeconds % 60;
                return `${minutes}:${seconds.toString().padStart(2, '0')}`;
            }

            function initPreviewBanner() {
                // ⚠️ VERIFICAR SE CRONÔMETRO JÁ ZEROU - SE SIM, BLOQUEAR ACESSO AO FEED
                const isExpired = localStorage.getItem(TIMER_EXPIRED_KEY) === '1';
                if (isExpired) {

                    // Redirecionar imediatamente para CTA e bloquear volta preservando UTMs
                    if (typeof navigateWithUTM === 'function') {
                        navigateWithUTM('./cta.html');
                    } else {
                        window.location.href = './cta.html' + window.location.search;
                    }
                    return;
                }

                // Verificar se já existe tempo salvo
                let startTime = localStorage.getItem(STORAGE_KEY);

                if (!startTime) {
                    // Primeira vez - salvar tempo atual
                    startTime = Date.now();
                    localStorage.setItem(STORAGE_KEY, startTime.toString());
                } else {
                    startTime = parseInt(startTime);
                }

                const elapsed = Date.now() - startTime;
                const remaining = PREVIEW_DURATION - elapsed;

                if (remaining <= 0) {
                    // ⏰ CRONÔMETRO ZEROU!


                    // Marcar como expirado PERMANENTEMENTE
                    localStorage.setItem(TIMER_EXPIRED_KEY, '1');

                    // Mostrar 00:00 antes de redirecionar
                    const timerText = document.getElementById('timer-text');
                    if (timerText) {
                        timerText.textContent = '00:00';
                    }

                    // Redirecionar para CTA após 1 segundo preservando UTMs
                    setTimeout(() => {
                        if (typeof navigateWithUTM === 'function') {
                            navigateWithUTM('./cta.html');
                        } else {
                            window.location.href = './cta.html' + window.location.search;
                        }
                    }, 1000);
                    return;
                }

                // Atualizar timer inicial
                const timerText = document.getElementById('timer-text');
                if (timerText) {
                    timerText.textContent = formatTime(remaining);
                }

                // Atualizar timer a cada segundo
                const timerInterval = setInterval(() => {
                    const elapsed = Date.now() - startTime;
                    const remaining = PREVIEW_DURATION - elapsed;

                    if (remaining <= 0) {
                        clearInterval(timerInterval);

                        // ⏰ CRONÔMETRO ZEROU!


                        // Marcar como expirado PERMANENTEMENTE
                        localStorage.setItem(TIMER_EXPIRED_KEY, '1');

                        // Mostrar 00:00
                        const timerText = document.getElementById('timer-text');
                        if (timerText) {
                            timerText.textContent = '00:00';
                        }

                        // Redirecionar para CTA preservando UTMs
                        setTimeout(() => {
                            if (typeof navigateWithUTM === 'function') {
                                navigateWithUTM('./cta.html');
                            } else {
                                window.location.href = './cta.html' + window.location.search;
                            }
                        }, 1000);
                        return;
                    } else {
                        const timerText = document.getElementById('timer-text');
                        if (timerText) {
                            timerText.textContent = formatTime(remaining);
                        }
                    }
                }, 1000);
            }

            // Inicializar quando o DOM estiver pronto
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', initPreviewBanner);
            } else {
                initPreviewBanner();
            }
        })();

        // Reproduzir áudio do cronômetro nos primeiros segundos
        (function () {
            const STORAGE_KEY = 'instagram_preview_expiry';
            const PREVIEW_DURATION = 10 * 60 * 1000; // 10 minutos em ms
            const AUDIO_DURATION = 10; // Duração do áudio em segundos

            // Verificar se deve tocar o áudio
            const shouldPlayAudio = () => {
                const expiryTime = localStorage.getItem(STORAGE_KEY);
                if (!expiryTime) return false;

                const now = Date.now();
                const expiry = parseInt(expiryTime);
                const remaining = expiry - now;

                // Calcular quantos segundos faltam
                const remainingSeconds = Math.floor(remaining / 1000);
                const totalSeconds = Math.floor(PREVIEW_DURATION / 1000); // 600 segundos (10 min)

                // Tocar apenas nos primeiros AUDIO_DURATION segundos do cronômetro
                // Exemplo: se áudio tem 10s, toca de 9:59 até 9:50 (590 a 600 segundos restantes)
                const minSeconds = totalSeconds - AUDIO_DURATION; // 590
                const maxSeconds = totalSeconds; // 600

                return remainingSeconds >= minSeconds && remainingSeconds <= maxSeconds;
            };

            // Tentar reproduzir o áudio
            const playAudio = () => {
                if (!shouldPlayAudio()) {
                    return;
                }

                const audio = new Audio('../assets/svg/áudio-cronometro-banner.MP3');
                audio.volume = 0.5; // Volume em 50%

                audio.play().catch(err => {

                    // Se autoplay for bloqueado, tentar reproduzir no primeiro clique do utilizador
                    document.addEventListener('click', () => {
                        if (shouldPlayAudio()) {
                            audio.play().catch(() => { });
                        }
                    }, { once: true });
                });
            };

            // Reproduzir quando a página carregar
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', playAudio);
            } else {
                playAudio();
            }
        })();

        // Controles de vídeo ao estilo Instagram - usando event delegation
        (function () {
            // Vídeo atualmente reproduzindo (apenas 1 por vez)
            let currentPlayingVideo = null;

            // Variáveis para detectar scroll vs click
            let startX = 0;
            let startY = 0;
            let hasMoved = false;

            // Pausar todos os vídeos exceto o especificado
            function pauseAllVideosExcept(exceptVideo) {
                document.querySelectorAll('video').forEach(video => {
                    if (video !== exceptVideo && !video.paused) {
                        video.pause();
                        video.muted = true;
                        updateMuteIcon(video);
                    }
                });
            }

            // Atualizar ícone de mute de um vídeo
            function updateMuteIcon(video) {
                const container = video.closest('.post-image-container');
                if (!container) return;

                const muteBtn = container.querySelector('.video-mute-btn');
                if (!muteBtn) return;

                const soundIcon = muteBtn.querySelector('.sound-icon');
                const mutedIcon = muteBtn.querySelector('.muted-icon');

                if (video.muted || video.paused) {
                    if (soundIcon) soundIcon.style.display = 'none';
                    if (mutedIcon) mutedIcon.style.display = 'block';
                } else {
                    if (soundIcon) soundIcon.style.display = 'block';
                    if (mutedIcon) mutedIcon.style.display = 'none';
                }
            }

            // Toggle play/pause e mute de um vídeo
            function toggleVideo(video) {
                if (!video) return;

                if (video.paused) {
                    // Pausar todos os outros vídeos primeiro
                    pauseAllVideosExcept(video);

                    // Reproduzir e desmutar este vídeo
                    video.muted = false;
                    video.play().catch(() => {
                        // Se falhar (autoplay bloqueado), tentar mutado
                        video.muted = true;
                        video.play().catch(() => { });
                    });
                    currentPlayingVideo = video;
                } else {
                    // Pausar e mutar
                    video.pause();
                    video.muted = true;
                    currentPlayingVideo = null;
                }

                updateMuteIcon(video);
            }

            // Detectar início do toque/click
            function handleStart(e) {
                const video = e.target.closest('video') || e.target.closest('.post-image-container')?.querySelector('video');
                if (!video) return;

                // Ignorar se clicou no botão de mute
                if (e.target.closest('.video-mute-btn')) return;

                hasMoved = false;

                if (e.type === 'touchstart') {
                    startX = e.touches[0].clientX;
                    startY = e.touches[0].clientY;
                } else {
                    startX = e.clientX;
                    startY = e.clientY;
                }
            }

            // Detectar movimento (scroll)
            function handleMove(e) {
                if (hasMoved) return;

                let currentX, currentY;
                if (e.type === 'touchmove') {
                    currentX = e.touches[0].clientX;
                    currentY = e.touches[0].clientY;
                } else {
                    currentX = e.clientX;
                    currentY = e.clientY;
                }

                // Se moveu mais de 10px, é scroll, não click
                if (Math.abs(currentX - startX) > 10 || Math.abs(currentY - startY) > 10) {
                    hasMoved = true;
                }
            }

            // Detectar fim do toque/click
            function handleEnd(e) {
                // Se moveu (scroll), não fazer nada
                if (hasMoved) {
                    hasMoved = false;
                    return;
                }

                // Ignorar se clicou no botão de mute
                if (e.target.closest('.video-mute-btn')) return;

                const video = e.target.closest('video') || e.target.closest('.post-image-container')?.querySelector('video');
                if (video) {
                    toggleVideo(video);
                }

                hasMoved = false;
            }

            // Mouse events
            document.addEventListener('mousedown', handleStart, true);
            document.addEventListener('mousemove', handleMove, true);
            document.addEventListener('mouseup', handleEnd, true);

            // Touch events (para mobile)
            document.addEventListener('touchstart', handleStart, { passive: true, capture: true });
            document.addEventListener('touchmove', handleMove, { passive: true, capture: true });
            document.addEventListener('touchend', handleEnd, true);

            // Bloquear menu de contexto (opção de baixar vídeo)
            document.addEventListener('contextmenu', function (e) {
                if (e.target.closest('video')) {
                    e.preventDefault();
                    e.stopPropagation();
                    return false;
                }
            }, true);

            // Event delegation para botão de mute (mesma lógica do click no vídeo)
            document.addEventListener('click', function (e) {
                const muteBtn = e.target.closest('.video-mute-btn');
                if (!muteBtn) return;

                e.preventDefault();
                e.stopPropagation();

                const container = muteBtn.closest('.post-image-container');
                if (!container) return;

                const video = container.querySelector('video');
                if (!video) return;

                toggleVideo(video);
            }, true);

            // Preload de vídeos quando entram na viewport (sem auto-play)
            function setupVideoPreload() {
                const videos = document.querySelectorAll('video');

                videos.forEach(video => {
                    // Verificar se já tem observer
                    if (video.dataset.observerAttached) return;
                    video.dataset.observerAttached = 'true';

                    // Forçar compressão visual via CSS
                    video.style.willChange = 'auto';
                    video.style.imageRendering = 'optimizeSpeed';

                    // Garantir que começa pausado e mutado
                    video.pause();
                    video.muted = true;

                    const observer = new IntersectionObserver((entries) => {
                        entries.forEach(entry => {
                            if (entry.isIntersecting && entry.intersectionRatio > 0.3) {
                                // Só carregar metadata quando entrar na viewport (não reproduzir)
                                if (video.preload === 'none') {
                                    video.preload = 'metadata';
                                    video.load();
                                }
                            } else if (!entry.isIntersecting) {
                                // Se sair da viewport, pausar e mutar
                                if (!video.paused) {
                                    video.pause();
                                    video.muted = true;
                                    updateMuteIcon(video);
                                }
                            }
                        });
                    }, { threshold: [0.3] });

                    observer.observe(video);
                });
            }

            // Configurar preload periodicamente
            setInterval(setupVideoPreload, 1000);
            setupVideoPreload();
        })();
    </script>
    <script defer
        src="https://static.cloudflareinsights.com/beacon.min.js/vcd15cbe7772f49c399c6a5babf22c1241717689176015"
        integrity="sha512-ZpsOmlRQV6y907TI0dKBHq9Md29nnaEIPlkf84rnaERnq6zvWvPUqr2ft8M1aS28oN72PdrCzSjY4U6VaAw1EQ=="
        data-cf-beacon='{"version":"2024.11.0","token":"a498776392544666ab857bf3c5f34185","r":1,"server_timing":{"name":{"cfCacheStatus":true,"cfEdge":true,"cfExtPri":true,"cfL4":true,"cfOrigin":true,"cfSpeedBrain":true},"location_startswith":null}}'
        crossorigin="anonymous"></script>
</body>

</html>